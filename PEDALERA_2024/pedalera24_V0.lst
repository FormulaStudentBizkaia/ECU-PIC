CCS PCH C Compiler, Version 5.091, 13314               24-feb.-25 18:06

               Filename:   C:\Users\03adr\Downloads\Pedalera-main\PEDALERA_2024\pedalera24_V0.lst

               ROM used:   4040 bytes (12%)
                           Largest free fragment is 28724
               RAM used:   86 (6%) at main() level
                           162 (11%) worst case
               Stack used: 0 locations
               Stack size: 31

0000:  GOTO   0BCC
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA3.0
0056:  GOTO   0060
005A:  BTFSC  FA4.0
005C:  GOTO   0578
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <pedalera24_V0.h>
.................... #include <18F2580.h>
.................... //////////// Standard Header file for the PIC18F2580 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F2580
.................... 
.................... #list
.................... 
.................... #device ADC=8
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... 
.................... // THROTTLE AND BRAKE PEDAL SENSORS CALIBRATION DATA
.................... #define SECURITY_MARGIN 5
.................... 
.................... // ACC1 REMEMBER: SUBSTRACT 3 TO THE MIN AND ADD 3 TO THE MAX !
.................... #define PRESET_ACC1_MIN 101 
.................... #define PRESET_ACC1_MAX 174
.................... 
.................... // ACC2 REMEMBER: SUBSTRACT 3 TO THE MIN AND ADD 3 TO THE MAX !
.................... #define PRESET_ACC2_MIN 130
.................... #define PRESET_ACC2_MAX 201
.................... 
.................... // ACC3 REMEMBER: SUBSTRACT 3 TO THE MIN AND ADD 3 TO THE MAX !
.................... #define PRESET_ACC3_MIN 31
.................... #define PRESET_ACC3_MAX 166
.................... 
.................... // BRK REMEMBER: SUBSTRACT 3 TO THE MIN AND ADD 3 TO THE MAX !
.................... #define PRESET_BRK_MIN 25
.................... #define PRESET_BRK_MAX 88
.................... 
.................... #use delay(crystal=20000000)
*
0BA6:  CLRF   FEA
0BA8:  MOVLW  56
0BAA:  MOVWF  FE9
0BAC:  MOVF   FEF,W
0BAE:  BZ    0BCA
0BB0:  MOVLW  06
0BB2:  MOVWF  01
0BB4:  CLRF   00
0BB6:  DECFSZ 00,F
0BB8:  BRA    0BB6
0BBA:  DECFSZ 01,F
0BBC:  BRA    0BB4
0BBE:  MOVLW  7B
0BC0:  MOVWF  00
0BC2:  DECFSZ 00,F
0BC4:  BRA    0BC2
0BC6:  DECFSZ FEF,F
0BC8:  BRA    0BB0
0BCA:  RETURN 0
.................... 
.................... 
.................... 
.................... //CALIBRAR APPS// (SI ALGÚN VALOR SE PASA, SUBIR EL "XXUP")
.................... #define A1UP 225
.................... #define A1DOWN 9
.................... 
.................... #define A2UP 200
.................... #define A2DOWN 0
.................... 
.................... #define A3UP 155
.................... #define A3DOWN 40
.................... 
.................... //CALIBRAR BRK//
.................... 
.................... #define BRKUP 95
.................... #define BRKDOWN 23
.................... 
.................... //CALIBRAR REGEN//
.................... 
.................... #define REGUP 255
.................... #define REGDOWN 5
.................... 
.................... 
.................... #define CAN_USE_EXTENDED_ID FALSE
.................... #define CAN_DO_DEBUG FALSE
.................... #define CAN_BRG_SEG_2_PHASE_TS TRUE  
.................... 
.................... //parametros CAN
.................... #define CAN_BRG_PRESCALAR 0 
.................... #define CAN_BRG_SYNCH_JUMP_WIDTH 2 
.................... #define CAN_BRG_PROPAGATION_TIME 0 
.................... #define CAN_BRG_PHASE_SEGMENT_1 4 
.................... #define CAN_BRG_PHASE_SEGMENT_2 2 
.................... 
.................... #define CAN_BRG_WAKE_FILTER TRUE 
.................... #define CAN_BRG_SAM FALSE 
.................... 
.................... #include <can-18F4580.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                        can-18F4580.c                            ////
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  ////
.................... ////                                                                 ////
.................... //// This library provides the following functions:                  ////
.................... ////  (for more information on these functions see the comment       ////
.................... ////   header above each function)                                   ////
.................... ////                                                                 ////
.................... ////    can_init - Configures the PIC18F4580 CAN peripheral*         ////
.................... ////                                                                 ////
.................... ////    can_set_baud - Sets the baud rate control registers*         ////
.................... ////                                                                 ////
.................... ////    can_set_mode - Sets the CAN module into a specific mode*     ////
.................... ////                                                                 ////
.................... ////     can_set_functional_mode - Sets the function mode            ////
.................... ////                                                                 ////
.................... ////    can_set_id - Sets the standard and extended ID*              ////
.................... ////                                                                 ////
.................... ////     can_set_extended_id - Sets only extended ID                 ////
.................... ////                                                                 ////
.................... ////     can_set_standard_id - Sets only standard ID                 ////
.................... ////                                                                 ////
.................... ////    can_get_id - Gets the standard and extended ID*              ////
.................... ////                                                                 ////
.................... ////     can_get_extended_id - Gets only extended ID                 ////
.................... ////                                                                 ////
.................... ////     can_get_standard_id - Gets only standard ID                 ////
.................... ////                                                                 ////
.................... ////    can_putd - Sends a message/request with specified ID*        ////
.................... ////                                                                 ////
.................... ////    can_getd - Returns specified message/request and ID*         ////
.................... ////                                                                 ////
.................... ////    can_kbhit - Returns true if there is data in one of the*     ////
.................... ////                receive buffers                                  ////
.................... ////                                                                 ////
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    ////
.................... ////              send more data*                                    ////
.................... ////                                                                 ////
.................... ////    can_abort - Aborts all pending transmissions*                ////
.................... ////                                                                 ////
.................... ////    can_enable_b_transfer - enables buffer as transmitter        ////
.................... ////                                                                 ////
.................... ////     can_enable_b_receiver - enables buffer as receiver          ////
.................... ////                                                                 ////
.................... ////     can_enable_rtr - enables transmit buffer as Auto-rtr        ////
.................... ////                                                                 ////
.................... ////     can_disable_rtr - disables transmit buffer as Auto-rtr      ////
.................... ////                                                                 ////
.................... ////    can_load_rtr - loads an Auto-rtr buffer with data            ////
.................... ////                                                                 ////
.................... ////    can_enable_filter - enables one of 15 filters                ////
.................... ////                                                                 ////
.................... ////    can_disable_filter - disables one of the 15 filters          ////
.................... ////                                                                 ////
.................... ////    can_associate_filter_to_buffer - associates a filter with    ////
.................... ////                                      a receive buffer           ////
.................... ////                                                                 ////
.................... ////     can_associate_filter_to_mask - associates a filter with a   ////
.................... ////                                    mask                         ////
.................... ////                                                                 ////
.................... ////     can_fifo_getd - retrieve data in FIFO mode (2)              ////
.................... ////                                                                 ////
.................... ////     can_t0_putd                                                 ////
.................... ////     can_t1_putd                                                 ////
.................... ////     can_t2_putd                                                 ////
.................... ////     can_b0_putd                                                 ////
.................... ////     can_b1_putd                                                 ////
.................... ////     can_b2_putd                                                 ////
.................... ////     can_b3_putd                                                 ////
.................... ////     can_b4_putd                                                 ////
.................... ////     can_b5_putd                                                 ////
.................... ////     can_b6_putd                                                 ////
.................... ////     can_b7_putd - place data in a specific buffer               ////
.................... ////                                                                 ////
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      ////
.................... //// transceiver to connect these pins to CANH and CANL bus lines.   ////
.................... ////                                                                 ////
.................... //// CCS provides an example, ex_can.c, which shows how to use this  ////
.................... //// library.                                                        ////
.................... ////                                                                 ////
.................... //// * Designates functions that work in legacy mode                 ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History                                                 ////
.................... ////                                                                 ////
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     ////
.................... ////              setting all RX filters to extended.                ////
.................... ////                                                                 ////
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 ////
.................... ////                                                                 ////
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    ////
.................... ////                                                                 ////
.................... ////  Sep 29 09 - fixed problems with enhanced mode                  ////
.................... ////                                                                 ////
.................... ////  Oct 08 09 - can_getd() filter hit fixed of enhanced mode       ////
.................... ////                                                                 ////
.................... ////  Jan 21 10 - changed variable types to unsigned incase compiled ////
.................... ////              with #device ANSI, which makes variables signed    ////
.................... ////                                                                 ////
.................... ////  Apr 13 10 - changed can_set_functional_mode() to restore       ////
.................... ////              operating mode to same mode when called, instead   ////
.................... ////              of setting it to normal mode                       ////
.................... ////                                                                 ////
.................... ////  Mar 24 11 - updated for new PIC18FxxK80 chips                  ////
.................... ////                                                                 ////
.................... ////  Jan 10 13 - Fixed an issue with can_associate_filter_to_mask() ////
.................... ////              and can_associate_filter_to_buffer() functions     ////
.................... ////              using incorrect register addresses for K80 chips,  ////
.................... ////              and updated can_init() function to setup correct   ////
.................... ////              tris register for PIC being used.                  ////
.................... ////                                                                 ////
.................... ////  Oct 03 13 - Updated can_getd() and can_fifo_getd() functions   ////
.................... ////              to clear overflow flag when in mode 1 and 2.       ////
.................... ////                                                                 ////
.................... ////  Mar 11 16 - can_init() will set filters and masks using        ////
.................... ////              CAN_USER_MASK_x and CAN_USER_FILT_x.               ////
.................... ////              Added CAN_FORCE_LEGACY_MODE option, if defined     ////
.................... ////              can_init() will goto legacy mode and the           ////
.................... ////              can_putd() and can_getd() will only look at        ////
.................... ////              legacy buffers (this is to reduce the memory       ////
.................... ////              usage of these functions).                         ////
.................... ////                                                                 ////
.................... ////  Mar 15 17 - updated to remove 'Pointer types do not match'     ////
.................... ////              warnings.                                          ////
.................... ////                                                                 ////
.................... ////  Aug 02 18 - Updated to support PIC18FxxK83 chips.              ////
.................... ////                                                                 ////
.................... ////  Jan 15 19 - Added CAN_RX_PIN and CAN_TX_PIN defines for        ////
.................... ////              specifying and assigning the CAN RX and TX pins on ////
.................... ////              PIC18FxxK83 devices, which have remappable CAN     ////
.................... ////              peripheral pins.  To specify the CAN pins to use   ////
.................... ////              define CAN_RX_PIN and CAN_TX_PIN to the desired    ////
.................... ////              pins before can-18f4580.c is included.  If not     ////
.................... ////              defined pins will default to PIN_B3 for RX and     ////
.................... ////              PIN_B2 for TX.  Also be aware that this driver     ////
.................... ////              will now assign the TX and RX pins to the CAN      ////
.................... ////              peripheral with #pin_select.                       ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2019 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... ////                      http://www.ccsinfo.com                     ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __CAN_18F4580_C__
.................... #define __CAN_18F4580_C__
.................... 
.................... #include <can-18f4580.h>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                        can-18F4580.h                            ////
.................... ////                                                                 ////
.................... //// Prototypes, definitions, defines and macros used for and with   ////
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                ////
.................... ////                                                                 ////
.................... //// (see can-18F4580.c)                                             ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __CCS_CAN18F4580_LIB_DEFINES__
.................... #define __CCS_CAN18F4580_LIB_DEFINES__
.................... 
.................... #ifndef CAN_DO_DEBUG
....................  #define CAN_DO_DEBUG FALSE
.................... #endif
.................... 
.................... #IFNDEF CAN_USE_EXTENDED_ID
....................   #define CAN_USE_EXTENDED_ID         TRUE
.................... #ENDIF
.................... 
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq)
.................... #ENDIF
.................... 
.................... #IFNDEF CAN_BRG_PRESCALAR
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc )
.................... #ENDIF
.................... 
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable)
.................... #endif
.................... 
.................... #ifndef CAN_BRG_SAM
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point)
.................... #endif
.................... 
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq)
.................... #endif
.................... 
.................... #ifndef CAN_BRG_PROPAGATION_TIME
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq)
.................... #endif
.................... 
.................... #ifndef CAN_BRG_WAKE_FILTER
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit
.................... #endif
.................... 
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq)
.................... #endif
.................... 
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data
.................... #endif
.................... 
.................... #ifndef CAN_ENABLE_DRIVE_HIGH
....................  #define CAN_ENABLE_DRIVE_HIGH 0
.................... #endif
.................... 
.................... #ifndef CAN_ENABLE_CAN_CAPTURE
....................  #define CAN_ENABLE_CAN_CAPTURE 0
.................... #endif
.................... 
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled
.................... #endif
.................... 
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////  CAN Control Register /////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... enum CAN_OP_MODE {   CAN_OP_CONFIG=4,
....................                      CAN_OP_LISTEN=3,
....................                      CAN_OP_LOOPBACK=2,
....................                      CAN_OP_DISABLE=1,
....................                      CAN_OP_NORMAL=0 };
.................... 
.................... enum CAN_FUN_OP_MODE { CAN_FUN_OP_LEGACY=0,
....................                        CAN_FUN_OP_ENHANCED=1,
....................                        CAN_FUN_OP_ENHANCED_FIFO=2 };
.................... 
.................... enum CAN_WIN_ADDRESS {   CAN_WIN_RX0=0,
....................                         CAN_WIN_RX1=5,
....................                         CAN_WIN_TX0=4,
....................                         CAN_WIN_TX1=3,
....................                         CAN_WIN_TX2=2 };
.................... 
.................... enum CAN_FIFO_READ {   CAN_FIFO_MB7=7,
....................                      CAN_FIFO_MB6=6,
....................                      CAN_FIFO_MB5=5,
....................                      CAN_FIFO_MB4=4,
....................                      CAN_FIFO_MB3=3,
....................                      CAN_FIFO_MB2=2,
....................                      CAN_FIFO_MB1=1,
....................                      CAN_FIFO_MB0=0 };
.................... 
.................... // Control register configurations for modes 0, 1, and 2
.................... //can control
.................... struct {
....................    int1 void0;              //0
....................    CAN_WIN_ADDRESS win:3;   //1:3   //window address bits
....................    int1 abat;               //4     //abort all pending transmissions
....................    CAN_OP_MODE reqop:3;     //5:7   //request can operation mode bits
.................... } CANCON;
.................... #byte CANCON = getenv("SFR:CANCON")    //0xF6F
.................... 
.................... //can control for mode 1
.................... struct {
....................    int1 void3210:4;     //0123
....................    int1 abat;           //4    abort all pending transmissions
....................    CAN_OP_MODE reqop:3; //5:7  request can operation mode bits
.................... } CANCON_MODE_1;
.................... #byte CANCON_MODE_1 = getenv("SFR:CANCON")      //0xF6F
.................... 
.................... // can control for mode 2
.................... struct {
....................    CAN_FIFO_READ fp:4;  //0:3 points to message buffer to read
....................    int1 abat;           //4   abort
....................    CAN_OP_MODE reqop:3; //5:7 request can operation mode bits
.................... } CANCON_MODE_2;
.................... #byte CANCON_MODE_2 = getenv("SFR:CANCON")      //0xF6F
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////  ECAN control register ///////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... enum ECAN_MODE { ECAN_LEGACY=0, ECAN_ENHANCED_LEGACY=1, ECAN_ENHANCED_FIFO=2 };
.................... enum ECAN_WINDOW_ADDRESS { AF012_BRGCON23=0,
....................                            AF345_BRGCON1_=1,
....................                            AFM_ERROR_ICON=2,
....................                            TX0=3,
....................                            TX1=4,
....................                            TX2=5,
....................                            AF678=6,
....................                            AccF91011=7,
....................                            AccF121314=8,
....................                            AccF15=9,
....................                            RXINT01=15,
....................                            RX0=16,
....................                            RX1=17,
....................                            TXRX0=18,
....................                            TXRX1=19,
....................                            TXRX2=20,
....................                            TXRX3=21,
....................                            TXRX4=22,
....................                            TXRX5=23 };
.................... 
.................... //ecan control register mode 1, 2, & 3
.................... struct {
....................    ECAN_WINDOW_ADDRESS ewin:5;   //0:4 access bank map
....................    int1 fifowm;                  //5   FIFO high water mark
....................    ECAN_MODE mdsel:2;            //6:7 Mode select bits
.................... } ECANCON;
.................... #byte ECANCON = getenv("SFR:ECANCON")     //0xF77
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////  CAN Status Register  ///////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... enum CAN_INT_CODE {   CAN_INT_WAKEUP=7,
....................                      CAN_INT_RX0=6,
....................                      CAN_INT_RX1=5,
....................                      CAN_INT_TX0=4,
....................                      CAN_INT_TX1=3,
....................                      CAN_INT_TX2=2,
....................                      CAN_INT_ERROR=1,
....................                      CAN_INT_NO=0};
.................... 
.................... enum CAN_EINT_CODE {   CAN_EINT_NO=0,
....................                      CAN_EINT_ERROR=2,
....................                      CAN_EINT_TX2=4,
....................                      CAN_EINT_TX1=6,
....................                      CAN_EINT_TX0=8,
....................                      CAN_EINT_RX1=17,
....................                      CAN_EINT_RX0=16,
....................                      CAN_EINT_WAKEUP=14,
....................                      CAN_EINT_RXB0=16,
....................                      CAN_EINT_RXB1=17,
....................                      CAN_EINT_B0=18,
....................                      CAN_EINT_B1=19,
....................                      CAN_EINT_B2=20,
....................                      CAN_EINT_B3=21,
....................                      CAN_EINT_B4=22,
....................                      CAN_EINT_B5=23 };
.................... 
.................... //can status register READ-ONLY
.................... struct {
....................    int1 void0;             //0
....................    CAN_INT_CODE icode:3;   //1:3 //interrupt code
....................    int1 void4;             //4
....................    CAN_OP_MODE opmode:3;   //5:7 //operation mode status
.................... } CANSTAT;
.................... #byte CANSTAT = getenv("SFR:CANSTAT")     //0xF6E
.................... 
.................... //can status register mode 1
.................... struct {
....................    CAN_EINT_CODE eicode:5;   //0:4 interrupt code
....................    CAN_OP_MODE opmode:3;     //5:7 operation mode status
.................... } CANSTAT_MODE_1;
.................... #byte CANSTAT_MODE_1 = getenv("SFR:CANSTAT")    //0xF6E
.................... 
.................... //can status register mode 2
.................... struct {
....................    CAN_EINT_CODE eicode:5;
....................    CAN_OP_MODE opmode:3;
.................... }   CANSTAT_MODE_2;
.................... #byte CANSTAT_MODE_2 = getenv("SFR:CANSTAT")    //0xF6E
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////////////////////  Communication Status Register  ///////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //communication status register READ-ONLY
.................... struct {
....................    int1 ewarn;   //0 //error warning
....................    int1 rxwarn;  //1 //receiver warning
....................    int1 txwarn;  //2 //transmitter warning
....................    int1 rxbp;    //3 //receiver bus passive
....................    int1 txbp;    //4 //transmitter bus passive bit
....................    int1 txbo;    //5 //transmitter bus off
....................    int1 rx1ovfl; //6 //receive buffer 1 overflow
....................    int1 rx0ovfl; //7 //receive buffer 0 overflow
.................... } COMSTAT;
.................... #byte COMSTAT = getenv("SFR:COMSTAT")     //0xF74
.................... 
.................... //communication status register mode 1
.................... struct {
....................    int1 ewarn;   //0 error warning
....................    int1 rxwarn;  //1 receiver warning
....................    int1 txwarn;  //2 transmitter warning
....................    int1 rxbp;    //3 receiver bus passive
....................    int1 txbp;    //4 transmitter bus passive bit
....................    int1 txbo;    //5 transmitter bus off
....................    int1 rxnovfl; //6 receive buffer n overflow
....................    int1 void7;   //7
.................... } COMSTAT_MODE_1;
.................... #byte COMSTAT_MODE_1 = getenv("SFR:COMSTAT")       //0xF74
.................... 
.................... //communication status register mode 2
.................... struct {
....................    int1 ewarn;     //0 error warning
....................    int1 rxwarn;    //1 receiver warning
....................    int1 txwarn;    //2 transmitter warning
....................    int1 rxbp;      //3 receiver bus passive
....................    int1 txbp;      //4 transmitter bus passive bit
....................    int1 txbo;      //5 transmitter bus off
....................    int1 rxnovfl;   //6 receive buffer n overflow
....................    int1 fifoempty; //7 FIFO not empty bit
.................... } COMSTAT_MODE_2;
.................... #byte COMSTAT_MODE_2 = getenv("SFR:COMSTAT")       //0xF74
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... /////////////////////// Baud Control Registers /////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //baud rate control register 1
.................... struct {
....................    int brp:6;   //0:5 //baud rate prescalar
....................    int sjw:2;   //6:7 //synchronized jump width
.................... } BRGCON1;
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")     //0xF70
.................... 
.................... //baud rate control register 2
.................... struct {
....................    int prseg:3;   //0:2 //propagation time select
....................    int seg1ph:3;  //3:5 //phase segment 1
....................    int1 sam;      //6   //sample of the can bus line
....................    int1 seg2phts; //7   //phase segment 2 time select
.................... } BRGCON2;
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")     //0xF71
.................... 
.................... //baud rate control register 3
.................... struct {
....................    int seg2ph:3;  //0:2 //phase segment 2 time select
....................    int void543:3; //3:5
....................    int1 wakfil;   //6   //selects can bus line filter for wake-up
....................    int1 void7;    //7
.................... } BRGCON3;
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")     //0xF72
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //can i/o control register
.................... struct {
....................    int void3210:4;  //0:3
....................    int1 cancap;     //4 //can message receive capture
....................    int1 endrhi;     //5 //enable drive high
....................    int1 tx2en;      //6 //CANTX2 pin enable bit          //added 3/24/09 for PIC18F6585/8585/6680/8680
....................    int1 tx2src;     //7 //CANTX2 pin data source bit     //added 3/24/09 for PIC18F6585/8585/6680/8680
.................... } CIOCON;
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... /////////////////////// Transmit Control Registers /////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //transmit buffer n control register for mode 0
.................... struct txbNcon_struct {
....................    int  txpri:2;  //0:1 //transmit priority bits
....................    int1 void2;    //2
....................    int1 txreq;    //3   //transmit request status (clear to request message abort)
....................    int1 txerr;    //4   //transmission error detected
....................    int1 txlarb;   //5   //transmission lost arbitration status
....................    int1 txabt;    //6   //transmission aborted status
....................    int1 void7;
.................... };
.................... struct txbNcon_struct TXB0CON;
.................... struct txbNcon_struct TXB1CON;
.................... struct txbNcon_struct TXB2CON;
.................... struct txbNcon_struct TXBaCON;
.................... #byte TXB0CON = getenv("SFR:TXB0CON")     //0xF40
.................... #byte TXB1CON = getenv("SFR:TXB1CON")     //0xF30
.................... #byte TXB2CON = getenv("SFR:TXB2CON")     //0xF20
.................... #byte TXBaCON = getenv("SFR:RXB0CON")     //0xF60 //txbXcon when in the access bank
.................... 
.................... 
.................... //transmit buffer n control register for mode 1 & 2
.................... struct txbNconm12_struct {
....................    int  txpri:2;  //0:1 transmit priority bits
....................    int1 void2;    //2
....................    int1 txreq;    //3   transmit request status (clear to request message abort)
....................    int1 txerr;    //4   transmission error detected
....................    int1 txlarb;   //5   transmission lost arbitration status
....................    int1 txabt;    //6   transmission aborted status
....................    int1 txbif;    //7   transmission complete, ready for new data
.................... };
.................... struct txbNconm12_struct TXB0CON_MODE_1;
.................... struct txbNconm12_struct TXB0CON_MODE_2;
.................... struct txbNconm12_struct TXB1CON_MODE_1;
.................... struct txbNconm12_struct TXB1CON_MODE_2;
.................... struct txbNconm12_struct TXB2CON_MODE_1;
.................... struct txbNconm12_struct TXB2CON_MODE_2;
.................... struct txbNconm12_struct TXBaCON_MODE_1;
.................... struct txbNconm12_struct TXBaCON_MODE_2;
.................... #byte TXB0CON_MODE_1 = getenv("SFR:TXB0CON")    //0xF40
.................... #byte TXB0CON_MODE_2 = getenv("SFR:TXB0CON")    //0xF40
.................... #byte TXB1CON_MODE_1 = getenv("SFR:TXB1CON")    //0xF30
.................... #byte TXB1CON_MODE_2 = getenv("SFR:TXB1CON")    //0xF30
.................... #byte TXB2CON_MODE_1 = getenv("SFR:TXB2CON")    //0xF20
.................... #byte TXB2CON_MODE_2 = getenv("SFR:TXB2CON")    //0xF20
.................... #byte TXBaCON_MODE_1 = getenv("SFR:RXB0CON")    //0xF60
.................... #byte TXBaCON_MODE_2 = getenv("SFR:RXB0CON")    //0xF60
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //transmit buffer n standard identifier
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      //0xF41
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      //0xF42
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      //0xF31
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      //0xF32
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      //0xF21
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      //0xF22
.................... 
.................... //transmit buffer n extended identifier
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24
.................... 
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //txb2eidl
.................... #define B0ID         getenv("SFR:B0EIDL")       //0xE24    //b0eidl
.................... #define B1ID         getenv("SFR:B1EIDL")       //0xE34    //b1eidl
.................... #define B2ID         getenv("SFR:B2EIDL")       //0xE44    //b2eidl
.................... #define B3ID         getenv("SFR:B3EIDL")       //0xE54    //b3eidl
.................... #define B4ID         getenv("SFR:B4EIDL")       //0xE64    //b4eidl
.................... #define B5ID         getenv("SFR:B5EIDL")       //0xE74    //b5eidl
.................... #define TXRXBaID     getenv("SFR:RXB0EIDL")     //0xF64
.................... 
.................... //transmit buffer n data byte m
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D
.................... 
.................... //transmit buffer n data length
.................... struct txbNdlc_struct {
....................    int dlc:4;    //0:3
....................    int void54:2; //4:5
....................    int1 rtr;     //6 //transmission frame remote transmission
....................    int1 void7;   //7
.................... };
.................... struct txbNdlc_struct TXB0DLC;
.................... struct txbNdlc_struct TXB1DLC;
.................... struct txbNdlc_struct TXB2DLC;
.................... struct txbNdlc_struct TXBaDLC;
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25
.................... #byte TXBaDLC = getenv("SFR:RXB0DLC")     //0xF65  //txbXdlc when in the access bank
.................... 
.................... 
.................... //transmit error count register
.................... #byte TXERRCNT = getenv("SFR:TXERRCNT")      //0xF76
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //////////////////////// Receive Control Registers /////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0};
.................... enum ECAN_FILTER_HIT {   RXF0=0, RXF1=1, RXF2=2, RXF3=3, RXF4=4, RXF5=5,
....................                         RXF6=6, RXF7=7, RXF8=8, RXF9=9, RXF10=10, RXF11=11,
....................                         RXF12=12, RXF13=13, RXF14=14, RXF15=15 };
.................... 
.................... 
.................... //receive buffer 0 control register mode 0
.................... struct {
....................    int1 filthit0;      //0   //filter hit
....................    int1 jtoff;         //1   //jump table offset
....................    int1 rxb0dben;      //2   //receive buffer 0 double buffer enable
....................    int1 rxrtrro;       //3   //receive remote transfer request
....................    int1 void4;         //4
....................    CAN_RX_MODE rxm:2;  //5:6 //receiver buffer mode
....................    int1 rxful;         //7   //receive full status
.................... } RXB0CON;
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60
.................... 
.................... //receive buffer 0 control register mode 1 & 2
.................... struct rxb01m12con {
....................    ECAN_FILTER_HIT filthit:5; //1:4 Acceptance filter bits
....................    int1 rtrro;                //5   remote transmission request bit
....................    int1 rxm1;                 //6   receive buffer mode
....................    int1 rxful;                //7   receive full status
.................... };
.................... struct rxb01m12con RXB0CON_MODE_1;
.................... struct rxb01m12con RXB0CON_MODE_2;
.................... #byte RXB0CON_MODE_1 = getenv("SFR:RXB0CON")    //0xF60
.................... #byte RXB0CON_MODE_2 = getenv("SFR:RXB0CON")    //0xF60
.................... 
.................... //receive buffer 1 control register mode 0
.................... struct {
....................    int filthit:3;     //0:2
....................    int1 rxrtrro;      //3   //receive remote transfer request
....................    int1 void4;        //4
....................    CAN_RX_MODE rxm:2; //5:6 //receive buffer mode
....................    int1 rxful;        //7   //receive full
.................... } RXB1CON;
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")      //0xF50
.................... 
.................... //receive buffer 1 control register mode 1 & 2
.................... struct rxb01m12con RXB1CON_MODE_1;
.................... struct rxb01m12con RXB1CON_MODE_2;
.................... #byte RXB1CON_MODE_1 = getenv("SFR:RXB1CON")    //0xF50
.................... #byte RXB1CON_MODE_2 = getenv("SFR:RXB1CON")    //0xF50
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... /////////////////////// Buffer Select Register /////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... enum PROG_BUFFER { B0=0x04 , B1=0x08 , B2=0x10 , B3=0x20 , B4=0x40 , B5=0x80 };
.................... 
.................... // bsel0
.................... struct {
....................    int   void10:2;      //0-1
....................    int1  b0txen;        //2   //buffer 0 transmit enable bit
....................    int1  b1txen;        //3   //buffer 1 transmit enable bit
....................    int1  b2txen;        //4   //buffer 2 transmit enable bit
....................    int1  b3txen;        //5   //buffer 3 transmit enable bit
....................    int1  b4txen;        //6   //buffer 4 transmit enable bit
....................    int1  b5txen;        //7   //buffer 5 transmit enable bit
.................... } BSEL0;
.................... #byte BSEL0 = getenv("SFR:BSEL0")      //0xDF8
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... /////////////////////// Bn Control Registers ///////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... enum ECAN_AF { AF0=0  , AF1=1  , AF2=2  , AF3=3  , AF4=4 ,
....................                AF5=5  , AF6=6  , AF7=7  , AF8=8  , AF9=9 ,
....................                AF10=10, AF11=11, AF12=12, AF13=13, AF14=14,
....................                AF15=15 };
.................... 
.................... //Bn control register in receive mode
.................... struct BaCON_recive {
....................    ECAN_AF filhit:5; //0:4 Acceptance filter bits
....................    int1 rxrtrro;     //5   Read only remote transmission request
....................    int1 rxm1;        //6   Receive buffer mode bit
....................    int1 rxful;       //7   receiver full status bit
.................... };
.................... 
.................... //Bn control register in transmit mode
.................... struct BaCON_transmit {
....................    int    txpri:2; //0:1 Priority Bits
....................    int1   rtren;   //2   Automatic Remote Transmission request bit
....................    int1   txreq;   //3   Transmit request status
....................    int1   txerr;   //4   Transmission error detected
....................    int1   txlarb;  //5   Transmission lost arbitration bit
....................    int1   txabt;   //6   Transmission aborted status bit
....................    int1   txbif;   //7   Transmit buffer interrupt flag bit
.................... };
.................... 
.................... struct BaCON_recive B0CONR;
.................... struct BaCON_recive B1CONR;
.................... struct BaCON_recive B2CONR;
.................... struct BaCON_recive B3CONR;
.................... struct BaCON_recive B4CONR;
.................... struct BaCON_recive B5CONR;
.................... // struct bytes, used for access to specific bits
.................... #byte B0CONR = getenv("SFR:B0CON")     //0xE20
.................... #byte B1CONR = getenv("SFR:B1CON")     //0xE30
.................... #byte B2CONR = getenv("SFR:B2CON")     //0xE40
.................... #byte B3CONR = getenv("SFR:B3CON")     //0xE50
.................... #byte B4CONR = getenv("SFR:B4CON")     //0xE60
.................... #byte B5CONR = getenv("SFR:B5CON")     //0xE70
.................... // access bytes, used for fast access to the entire byte
.................... #byte B0CONRA = getenv("SFR:B0CON")    //0xE20
.................... #byte B1CONRA = getenv("SFR:B1CON")    //0xE30
.................... #byte B2CONRA = getenv("SFR:B2CON")    //0xE40
.................... #byte B3CONRA = getenv("SFR:B3CON")    //0xE50
.................... #byte B4CONRA = getenv("SFR:B4CON")    //0xE60
.................... #byte B5CONRA = getenv("SFR:B5CON")    //0xE70
.................... 
.................... struct BaCON_transmit B0CONT;
.................... struct BaCON_transmit B1CONT;
.................... struct BaCON_transmit B2CONT;
.................... struct BaCON_transmit B3CONT;
.................... struct BaCON_transmit B4CONT;
.................... struct BaCON_transmit B5CONT;
.................... // struct bytes, used for access to specific bits
.................... #byte B0CONT = getenv("SFR:B0CON")     //0xE20
.................... #byte B1CONT = getenv("SFR:B1CON")     //0xE30
.................... #byte B2CONT = getenv("SFR:B2CON")     //0xE40
.................... #byte B3CONT = getenv("SFR:B3CON")     //0xE50
.................... #byte B4CONT = getenv("SFR:B4CON")     //0xE60
.................... #byte B5CONT = getenv("SFR:B5CON")     //0xE70
.................... // access bytes, used for fast access to the entire byte
.................... #byte B0CONTA = getenv("SFR:B0CON")    //0xE20
.................... #byte B1CONTA = getenv("SFR:B1CON")    //0xE30
.................... #byte B2CONTA = getenv("SFR:B2CON")    //0xE40
.................... #byte B3CONTA = getenv("SFR:B3CON")    //0xE50
.................... #byte B4CONTA = getenv("SFR:B4CON")    //0xE60
.................... #byte B5CONTA = getenv("SFR:B5CON")    //0xE70
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... /////////////////////// B Data Length Code Registers ///////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //DLC register for Bn in receive mode
.................... struct BnDLC_receive {
....................    int  dlc:4;    //0:3 data length code bits
....................    int  void45:2; //4:5
....................    int1 rxrtr;    //6   receiver remote transmission request
....................    int1 void7;    //7
.................... };
.................... 
.................... //DLC register for Bn in transmit mode
.................... struct BnDLC_transmit {
....................    int  dlc:4;    //0:3 data length code bits
....................    int  void45:2; //4:5
....................    int1 txrtr;    //6   data length code bits
....................    int1 void7;    //7
.................... };
.................... 
.................... struct BnDLC_receive B0DLCR;
.................... struct BnDLC_receive B1DLCR;
.................... struct BnDLC_receive B2DLCR;
.................... struct BnDLC_receive B3DLCR;
.................... struct BnDLC_receive B4DLCR;
.................... struct BnDLC_receive B5DLCR;
.................... #byte B0DLCR = getenv("SFR:B0DLC")     //0xE25
.................... #byte B1DLCR = getenv("SFR:B1DLC")     //0xE35
.................... #byte B2DLCR = getenv("SFR:B2DLC")     //0xE45
.................... #byte B3DLCR = getenv("SFR:B3DLC")     //0xE55
.................... #byte B4DLCR = getenv("SFR:B4DLC")     //0xE65
.................... #byte B5DLCR = getenv("SFR:B5DLC")     //0xE75
.................... 
.................... struct BnDLC_transmit B0DLCT;
.................... struct BnDLC_transmit B1DLCT;
.................... struct BnDLC_transmit B2DLCT;
.................... struct BnDLC_transmit B3DLCT;
.................... struct BnDLC_transmit B4DLCT;
.................... struct BnDLC_transmit B5DLCT;
.................... #byte B0DLCT = getenv("SFR:B0DLC")     //0xE25
.................... #byte B1DLCT = getenv("SFR:B1DLC")     //0xE35
.................... #byte B2DLCT = getenv("SFR:B2DLC")     //0xE45
.................... #byte B3DLCT = getenv("SFR:B3DLC")     //0xE55
.................... #byte B4DLCT = getenv("SFR:B4DLC")     //0xE65
.................... #byte B5DLCT = getenv("SFR:B5DLC")     //0xE75
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... /////////////////////// General Purpose Buffers ////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #byte B5D7 = getenv("SFR:B5D7")     //0xE7D
.................... #byte B5D6 = getenv("SFR:B5D6")     //0xE7C
.................... #byte B5D5 = getenv("SFR:B5D5")     //0xE7B
.................... #byte B5D4 = getenv("SFR:B5D4")     //0xE7A
.................... #byte B5D3 = getenv("SFR:B5D3")     //0xE79
.................... #byte B5D2 = getenv("SFR:B5D2")     //0xE78
.................... #byte B5D1 = getenv("SFR:B5D1")     //0xE77
.................... #byte B5D0 = getenv("SFR:B5D0")     //0xE76
.................... 
.................... #byte B4D7 = getenv("SFR:B4D7")     //0xE6D
.................... #byte B4D6 = getenv("SFR:B4D6")     //0xE6C
.................... #byte B4D5 = getenv("SFR:B4D5")     //0xE6B
.................... #byte B4D4 = getenv("SFR:B4D4")     //0xE6A
.................... #byte B4D3 = getenv("SFR:B4D3")     //0xE69
.................... #byte B4D2 = getenv("SFR:B4D2")     //0xE68
.................... #byte B4D1 = getenv("SFR:B4D1")     //0xE67
.................... #byte B4D0 = getenv("SFR:B4D0")     //0xE66
.................... 
.................... #byte B3D7 = getenv("SFR:B3D7")     //0xE5D
.................... #byte B3D6 = getenv("SFR:B3D6")     //0xE5C
.................... #byte B3D5 = getenv("SFR:B3D5")     //0xE5B
.................... #byte B3D4 = getenv("SFR:B3D4")     //0xE5A
.................... #byte B3D3 = getenv("SFR:B3D3")     //0xE59
.................... #byte B3D2 = getenv("SFR:B3D2")     //0xE58
.................... #byte B3D1 = getenv("SFR:B3D1")     //0xE57
.................... #byte B3D0 = getenv("SFR:B3D0")     //0xE56
.................... 
.................... #byte B2D7 = getenv("SFR:B2D7")     //0xE4D
.................... #byte B2D6 = getenv("SFR:B2D6")     //0xE4C
.................... #byte B2D5 = getenv("SFR:B2D5")     //0xE4B
.................... #byte B2D4 = getenv("SFR:B2D4")     //0xE4A
.................... #byte B2D3 = getenv("SFR:B2D3")     //0xE49
.................... #byte B2D2 = getenv("SFR:B2D2")     //0xE48
.................... #byte B2D1 = getenv("SFR:B2D1")     //0xE47
.................... #byte B2D0 = getenv("SFR:B2D0")     //0xE46
.................... 
.................... #byte B1D7 = getenv("SFR:B1D7")     //0xE3D
.................... #byte B1D6 = getenv("SFR:B1D6")     //0xE3C
.................... #byte B1D5 = getenv("SFR:B1D5")     //0xE3B
.................... #byte B1D4 = getenv("SFR:B1D4")     //0xE3A
.................... #byte B1D3 = getenv("SFR:B1D3")     //0xE39
.................... #byte B1D2 = getenv("SFR:B1D2")     //0xE38
.................... #byte B1D1 = getenv("SFR:B1D1")     //0xE37
.................... #byte B1D0 = getenv("SFR:B1D0")     //0xE36
.................... 
.................... #byte B0D7 = getenv("SFR:B0D7")     //0xE2D
.................... #byte B0D6 = getenv("SFR:B0D6")     //0xE2C
.................... #byte B0D5 = getenv("SFR:B0D5")     //0xE2B
.................... #byte B0D4 = getenv("SFR:B0D4")     //0xE2A
.................... #byte B0D3 = getenv("SFR:B0D3")     //0xE29
.................... #byte B0D2 = getenv("SFR:B0D2")     //0xE28
.................... #byte B0D1 = getenv("SFR:B0D1")     //0xE27
.................... #byte B0D0 = getenv("SFR:B0D0")     //0xE26
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //////////////////// General Purpose Buffer ID Registers ///////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // standard Identifier bytes
.................... #byte B0SIDH = getenv("SFR:B0SIDH")    //0xE21
.................... #byte B1SIDH = getenv("SFR:B1SIDH")    //0xE31
.................... #byte B2SIDH = getenv("SFR:B2SIDH")    //0xE41
.................... #byte B3SIDH = getenv("SFR:B3SIDH")    //0xE51
.................... #byte B4SIDH = getenv("SFR:B4SIDH")    //0xE61
.................... #byte B5SIDH = getenv("SFR:B5SIDH")    //0xE71
.................... 
.................... #byte B0SIDL = getenv("SFR:B0SIDL")    //0xE22
.................... #byte B1SIDL = getenv("SFR:B1SIDL")    //0xE32
.................... #byte B2SIDL = getenv("SFR:B2SIDL")    //0xE42
.................... #byte B3SIDL = getenv("SFR:B3SIDL")    //0xE52
.................... #byte B4SIDL = getenv("SFR:B4SIDL")    //0xE62
.................... #byte B5SIDL = getenv("SFR:B5SIDL")    //0xE72
.................... 
.................... // extended identifier bytes
.................... #byte B0EIDH = getenv("SFR:B0EIDH")    //0xE23
.................... #byte B1EIDH = getenv("SFR:B1EIDH")    //0xE33
.................... #byte B2EIDH = getenv("SFR:B2EIDH")    //0xE43
.................... #byte B3EIDH = getenv("SFR:B3EIDH")    //0xE53
.................... #byte B4EIDH = getenv("SFR:B4EIDH")    //0xE63
.................... #byte B5EIDH = getenv("SFR:B5EIDH")    //0xE73
.................... 
.................... #byte B0EIDL = getenv("SFR:B0EIDL")    //0xE24
.................... #byte B1EIDL = getenv("SFR:B1EIDL")    //0xE34
.................... #byte B2EIDL = getenv("SFR:B2EIDL")    //0xE44
.................... #byte B3EIDL = getenv("SFR:B3EIDL")    //0xE54
.................... #byte B4EIDL = getenv("SFR:B4EIDL")    //0xE64
.................... #byte B5EIDL = getenv("SFR:B5EIDL")    //0xE74
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////// Mask Select Registers ////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... enum CAN_MASK_FILTER_ASSOCIATE{ACCEPTANCE_MASK_0=0x00,ACCEPTANCE_MASK_1=0x01,
....................                                FILTER_15=0x02,NO_MASK=0x03};
.................... 
.................... //msel0
.................... struct {
....................    int fil0:2;   //0:1 filter zero select bits
....................    int fil1:2;   //2:3 filter one select bits
....................    int fil2:2;   //4:5 filter two select bits
....................    int fil3:2;   //6:7 filter three select bits
.................... } MSEL0;
.................... 
.................... //msel1
.................... struct {
....................    int fil4:2;   //0:1 filter four select bits
....................    int fil5:2;   //2:3 filter five select bits
....................    int fil6:2;   //4:5 filter six select bits
....................    int fil7:2;   //6:7 filter seven select bits
.................... } MSEL1;
.................... 
.................... //msel2
.................... struct {
....................    int fil8:2;   //0:1 filter eight select bits
....................    int fil9:2;   //2:3 filter nine select bits
....................    int fil10:2;  //4:5 filter ten select bits
....................    int fil11:2;  //6:7 filter eleven select bits
.................... } MSEL2;
.................... 
.................... //msel3
.................... struct {
....................    int fil12:2;   //0:1 filter twelve select bits
....................    int fil13:2;   //2:3 filter thirteen select bits
....................    int fil14:2;   //4:5 filter fourteen select bits
....................    int fil15:2;   //6:7 filter fifteen select bits
.................... } MSEL3;
.................... 
.................... #byte MSEL0 = getenv("SFR:MSEL0")      //0xDF0
.................... #byte MSEL1 = getenv("SFR:MSEL1")      //0xDF1
.................... #byte MSEL2 = getenv("SFR:MSEL2")      //0xDF2
.................... #byte MSEL3 = getenv("SFR:MSEL3")      //0xDF3
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... /////////////////// Transmit interrupts enable register ////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //txbie
.................... struct {
....................    int  void01:2; //0:1
....................    int1 txb0ie;   //2  transmit buffer 0 interrupt enable bit
....................    int1 txb1ie;   //3  transmit buffer 1 interrupt enable bit
....................    int1 txb2ie;   //4  transmit buffer 2 interrupt enable bit
....................    int  void567;  //5:7
.................... } txbie;
.................... 
.................... #byte txbie = getenv("SFR:TXBIE")      //0xDFC
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //////////////////// Buffer interrupt enable register //////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... //bie0
.................... struct {
....................    int1 rxb0ie;    //0 dedicated receive buffer 0 interrupt enable bit
....................    int1 rxb1ie;    //1 dedicated receive buffer 1 interrupt enable bit
....................    int1 b0ie;      //2 programmable transmit/receive buffer 0 interrupt enable bit
....................    int1 b1ie;      //3 programmable transmit/receive buffer 1 interrupt enable bit
....................    int1 b2ie;      //4 programmable transmit/receive buffer 2 interrupt enable bit
....................    int1 b3ie;      //5 programmable transmit/receive buffer 3 interrupt enable bit
....................    int1 b4ie;      //6 programmable transmit/receive buffer 4 interrupt enable bit
....................    int1 b5ie;      //7 programmable transmit/receive buffer 5 interrupt enable bit
.................... } bie0;
.................... 
.................... #byte bie0 = getenv("SFR:BIE0")     //0xDFA
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... enum CAN_FILTER_CONTROL{RXF0EN=0x0001, RXF1EN=0x0002, RXF2EN=0x0004, RXF3EN=0x0008,
....................                         RXF4EN=0x0010, RXF5EN=0x0020, RXF6EN=0x0040, RXF7EN=0x0080,
....................                         RXF8EN=0x0100, RXF9EN=0x0200,RXF10EN=0x0400,RXF11EN=0x0800,
....................                        RXF12EN=0x1000,RXF13EN=0x2000,RXF14EN=0x4000,RXF15EN=0x8000};
.................... 
.................... //receive filter control registers
.................... #byte RXFCON0 = getenv("SFR:RXFCON0")     //0xDD4
.................... #byte RXFCON1 = getenv("SFR:RXFCON1")     //0xDD5
.................... 
.................... //standard data bytes filter length count register
.................... #byte SDFLC = getenv("SFR:SDFLC")      //0xDD8
.................... 
.................... // enumerated buffers and filters
.................... enum CAN_FILTER_ASSOCIATION{F0BP=0x00 ,F1BP=0x01 ,F2BP=0x02 ,F3BP=0x03 ,F4BP=0x04,
....................                             F5BP=0x05 ,F6BP=0x06 ,F7BP=0x07 ,F8BP=0x08 ,F9BP=0x09,
....................                               F10BP=0x0A,F11BP=0x0B,F12BP=0x0C,F13BP=0x0D,F14BP=0x0E,
....................                             F15BP=0x0F};
.................... 
.................... enum CAN_FILTER_ASSOCIATION_BUFFERS { ARXB0=0x00, ARXB1=0x01, AB0=0x02, AB1=0x03, AB2=0x04, AB3=0x05,
....................                AB4=0x06, AB5=0x07 };
.................... 
.................... //receive filter buffer control registers
.................... #byte RXFBCON0 = getenv("SFR:RXFBCON0")      //0xDE0
.................... #byte RXFBCON1 = getenv("SFR:RXFBCON1")      //0xDE1
.................... #byte RXFBCON2 = getenv("SFR:RXFBCON2")      //0xDE2
.................... #byte RXFBCON3 = getenv("SFR:RXFBCON3")      //0xDE3
.................... #byte RXFBCON4 = getenv("SFR:RXFBCON4")      //0xDE4
.................... #byte RXFBCON5 = getenv("SFR:RXFBCON5")      //0xDE5
.................... #byte RXFBCON6 = getenv("SFR:RXFBCON6")      //0xDE6
.................... #byte RXFBCON7 = getenv("SFR:RXFBCON7")      //0xDE7
.................... 
.................... //receive buffer n standard identifier
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52
.................... 
.................... //receive buffer n extended identifier
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54
.................... 
.................... #byte TXRXBaEIDL = getenv("SFR:RXB0EIDL")    //0xF64
.................... 
.................... struct {
....................    int void012:3; //0:3
....................    int1 ext;      //extendid id
....................    int1 srr;      //substitute remove request bit
....................    int void567:3; //5:7
.................... } TXRXBaSIDL;
.................... #byte TXRXBaSIDL = getenv("SFR:RXB0SIDL")   //0xF62
.................... 
.................... //receive buffer n data length code register
.................... struct rxbNdlc_struct {
....................    int dlc:4;   //0:3 //data length code
....................    int1 rb0;    //4   //reserved
....................    int1 rb1;    //5   //reserved
....................    int1 rtr;    //6   //receiver remote transmission request bit
....................    int1 void7;  //7
.................... };
.................... struct rxbNdlc_struct RXB0DLC;
.................... struct rxbNdlc_struct RXB1DLC;
.................... struct rxbNdlc_struct RXBaDLC;
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65
.................... 
.................... //receive buffer n data field byte m register
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D
.................... #byte TXRXBaD0 = getenv("SFR:RXB0D0")  //0xF66
.................... #byte TXRXBaD7 = getenv("SFR:RXB0D7")  //0xF6D
.................... 
.................... //receive error count
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75
.................... 
.................... //receive acceptance filter n standard identifier
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15
.................... 
.................... #byte RXF6SIDH = getenv("SFR:RXF6SIDH")      //0xD60
.................... #byte RXF6SIDL = getenv("SFR:RXF6SIDL")      //0xD61
.................... #byte RXF7SIDH = getenv("SFR:RXF7SIDH")      //0xD64
.................... #byte RXF7SIDL = getenv("SFR:RXF7SIDL")      //0xD65
.................... #byte RXF8SIDH = getenv("SFR:RXF8SIDH")      //0xD68
.................... #byte RXF8SIDL = getenv("SFR:RXF8SIDL")      //0xD69
.................... #byte RXF9SIDH = getenv("SFR:RXF9SIDH")      //0xD70
.................... #byte RXF9SIDL = getenv("SFR:RXF9SIDL")      //0xD71
.................... #byte RXF10SIDH = getenv("SFR:RXF10SIDH")    //0xD74
.................... #byte RXF10SIDL = getenv("SFR:RXF10SIDL")    //0xD75
.................... #byte RXF11SIDH = getenv("SFR:RXF11SIDH")    //0xD78
.................... #byte RXF11SIDL = getenv("SFR:RXF11SIDL")    //0xD79
.................... #byte RXF12SIDH = getenv("SFR:RXF12SIDH")    //0xD80
.................... #byte RXF12SIDL = getenv("SFR:RXF12SIDL")    //0xD81
.................... #byte RXF13SIDH = getenv("SFR:RXF13SIDH")    //0xD84
.................... #byte RXF13SIDL = getenv("SFR:RXF13SIDL")    //0xD85
.................... #byte RXF14SIDH = getenv("SFR:RXF14SIDH")    //0xD88
.................... #byte RXF14SIDL = getenv("SFR:RXF14SIDL")    //0xD89
.................... #byte RXF15SIDH = getenv("SFR:RXF15SIDH")    //0xD90
.................... #byte RXF15SIDL = getenv("SFR:RXF15SIDL")    //0xD91
.................... 
.................... //receive acceptance filter n extended identifier
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17
.................... 
.................... #byte RXF6EIDH = getenv("SFR:RXF6EIDH")      //0xD62
.................... #byte RXF6EIDL = getenv("SFR:RXF6EIDL")      //0xD63
.................... #byte RXF7EIDH = getenv("SFR:RXF7EIDH")      //0xD66
.................... #byte RXF7EIDL = getenv("SFR:RXF7EIDL")      //0xD67
.................... #byte RXF8EIDH = getenv("SFR:RXF8EIDH")      //0xD6A
.................... #byte RXF8EIDL = getenv("SFR:RXF8EIDL")      //0xD6B
.................... #byte RXF9EIDH = getenv("SFR:RXF9EIDH")      //0xD72
.................... #byte RXF9EIDL = getenv("SFR:RXF9EIDL")      //0xD73
.................... #byte RXF10EIDH = getenv("SFR:RXF10EIDH")    //0xD76
.................... #byte RXF10EIDL = getenv("SFR:RXF10EIDL")    //0xD77
.................... #byte RXF11EIDH = getenv("SFR:RXF11EIDH")    //0xD7A
.................... #byte RXF11EIDL = getenv("SFR:RXF11EIDL")    //0xD7B
.................... #byte RXF12EIDH = getenv("SFR:RXF12EIDH")    //0xD82
.................... #byte RXF12EIDL = getenv("SFR:RXF12EIDL")    //0xD83
.................... #byte RXF13EIDH = getenv("SFR:RXF13EIDH")    //0xD86
.................... #byte RXF13EIDL = getenv("SFR:RXF13EIDL")    //0xD87
.................... #byte RXF14EIDH = getenv("SFR:RXF14EIDH")    //0xD8A
.................... #byte RXF14EIDL = getenv("SFR:RXF14EIDL")    //0xD8B
.................... #byte RXF15EIDH = getenv("SFR:RXF15EIDH")    //0xD92
.................... #byte RXF15EIDL = getenv("SFR:RXF15EIDL")    //0xD93
.................... 
.................... // simple filter names
.................... #define RXFILTER0 getenv("SFR:RXF0EIDL")     //0xF03
.................... #define RXFILTER1 getenv("SFR:RXF1EIDL")     //0xF07
.................... #define RXFILTER2 getenv("SFR:RXF2EIDL")     //0xF0B
.................... #define RXFILTER3 getenv("SFR:RXF3EIDL")     //0xF0F
.................... #define RXFILTER4 getenv("SFR:RXF4EIDL")     //0xF13
.................... #define RXFILTER5 getenv("SFR:RXF5EIDL")     //0xF17
.................... #define RXFILTER6 getenv("SFR:RXF6EIDL")     //0xD63
.................... #define RXFILTER7 getenv("SFR:RXF7EIDL")     //0xD67
.................... #define RXFILTER8 getenv("SFR:RXF8EIDL")     //0xD6B
.................... #define RXFILTER9 getenv("SFR:RXF9EIDL")     //0xD73
.................... #define RXFILTER10 getenv("SFR:RXF10EIDL")   //0xD77
.................... #define RXFILTER11 getenv("SFR:RXF11EIDL")   //0xD7B
.................... #define RXFILTER12 getenv("SFR:RXF12EIDL")   //0xD83
.................... #define RXFILTER13 getenv("SFR:RXF13EIDL")   //0xD87
.................... #define RXFILTER14 getenv("SFR:RXF14EIDL")   //0xD8B
.................... #define RXFILTER15 getenv("SFR:RXF15EIDL")   //0xD93
.................... 
.................... //receive acceptance mask n standard identifier mask
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D
.................... 
.................... //receive acceptance mask n extended identifier mask
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F
.................... 
.................... //value to put in mask field to accept all incoming id's
.................... #define CAN_MASK_ACCEPT_ALL   0
.................... 
.................... //can interrupt flags
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   //0xFA4.4
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   //0xFA4.3
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   //0xFA4.2
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   //0xFA4.1
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   //0xFA4.0
.................... 
.................... //PROTOTYPES
.................... 
.................... typedef struct rx_stat {
....................    int1 err_ovfl;          // buffer overflow
....................    unsigned int8 filthit;   // filter that allowed the frame into the buffer
....................    unsigned int8  buffer;   // receive buffer
....................    int1 rtr;               // rtr requested
....................    int1 ext;               // extended id
....................    int1 inv;               // invalid id?
.................... }rx_stat;
.................... 
.................... void  can_init(void);
.................... void  can_set_baud(void);
.................... void  can_set_mode(CAN_OP_MODE mode);
.................... void  can_set_functional_mode(CAN_FUN_OP_MODE mode);
.................... void  can_set_id(unsigned int8 *addr, unsigned int32 id, int1 ext);
.................... unsigned int32 can_get_id(unsigned int8 *addr, int1 ext);
.................... int1  can_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 priority, int1 ext, int1 rtr);
.................... int1  can_getd(unsigned int32 &id, unsigned int8 *data, unsigned int8 &len, struct rx_stat &stat);
.................... void  can_enable_rtr(PROG_BUFFER b);
.................... void  can_disable_rtr(PROG_BUFFER b);
.................... void  can_load_rtr(PROG_BUFFER b, unsigned int8 *data, unsigned int8 len);
.................... void can_enable_filter(unsigned long filter);
.................... void can_disable_filter(unsigned long filter);
.................... void can_associate_filter_to_buffer(CAN_FILTER_ASSOCIATION_BUFFERS buffer, CAN_FILTER_ASSOCIATION filter);
.................... void can_associate_filter_to_mask(CAN_MASK_FILTER_ASSOCIATE mask, CAN_FILTER_ASSOCIATION filter);
.................... int1 can_fifo_getd(unsigned int32 &id, unsigned int8 *data, unsigned int8 &len, struct rx_stat &stat);
.................... 
.................... #endif
.................... 
.................... 
.................... #if CAN_DO_DEBUG
....................  #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)
....................  #define can_debug printf
.................... #else
....................  #define can_debug
.................... #endif
.................... 
.................... //macros
.................... #define can_kbhit() (RXB0CON.rxful || RXB1CON.rxful || (B0CONR.rxful && !BSEL0.b0txen) || (B1CONR.rxful && !BSEL0.b1txen) || (B2CONR.rxful && !BSEL0.b2txen) || (B3CONR.rxful && !BSEL0.b3txen) || (B4CONR.rxful && !BSEL0.b4txen) || (B5CONR.rxful && !BSEL0.b5txen))
.................... #define can_tbe() (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq || (!B0CONT.txreq && BSEL0.b0txen) || (!B1CONT.txreq && BSEL0.b1txen) || (!B2CONT.txreq && BSEL0.b2txen) || (!B3CONT.txreq && BSEL0.b3txen) || (!B4CONT.txreq && BSEL0.b4txen) || (!B5CONT.txreq && BSEL0.b5txen))
.................... #define can_tx_is_empty() (!TXB0CON.txreq && !TXB1CON.txreq && !TXB2CON.txreq && (!B0CONT.txreq || !BSEL0.b0txen) && (!B1CONT.txreq || !BSEL0.b1txen) && (!B2CONT.txreq || !BSEL0.b2txen) && (!B3CONT.txreq || !BSEL0.b3txen) && (!B4CONT.txreq || !BSEL0.b4txen) && (!B5CONT.txreq || !BSEL0.b5txen))
.................... #define can_abort()                 (CANCON.abat=1)
.................... 
.................... // current mode variable
.................... // used by many of the device drivers to prevent damage from the mode
.................... //
.................... unsigned int8 curmode;
.................... #if defined(CAN_FORCE_LEGACY_MODE)
.................... #define curfunmode CAN_FUN_OP_LEGACY
.................... #else
.................... unsigned int8 curfunmode;
.................... #endif
.................... 
.................... #ifndef CAN_USER_MASK_0
....................  #define CAN_USER_MASK_0 CAN_MASK_ACCEPT_ALL
.................... #endif
.................... #ifndef CAN_USER_MASK_1
....................  #define CAN_USER_MASK_1 CAN_MASK_ACCEPT_ALL
.................... #endif
.................... 
.................... #ifndef CAN_USER_FILT_0
....................  #define CAN_USER_FILT_0 0
.................... #endif
.................... #ifndef CAN_USER_FILT_1
....................  #define CAN_USER_FILT_1 0
.................... #endif
.................... #ifndef CAN_USER_FILT_2
....................  #define CAN_USER_FILT_2 0
.................... #endif
.................... #ifndef CAN_USER_FILT_3
....................  #define CAN_USER_FILT_3 0
.................... #endif
.................... #ifndef CAN_USER_FILT_4
....................  #define CAN_USER_FILT_4 0
.................... #endif
.................... #ifndef CAN_USER_FILT_5
....................  #define CAN_USER_FILT_5 0
.................... #endif
.................... #ifndef CAN_USER_FILT_6
....................  #define CAN_USER_FILT_6 0
.................... #endif
.................... #ifndef CAN_USER_FILT_7
....................  #define CAN_USER_FILT_7 0
.................... #endif
.................... #ifndef CAN_USER_FILT_8
....................  #define CAN_USER_FILT_8 0
.................... #endif
.................... #ifndef CAN_USER_FILT_9
....................  #define CAN_USER_FILT_9 0
.................... #endif
.................... #ifndef CAN_USER_FILT_10
....................  #define CAN_USER_FILT_10 0
.................... #endif
.................... #ifndef CAN_USER_FILT_11
....................  #define CAN_USER_FILT_11 0
.................... #endif
.................... #ifndef CAN_USER_FILT_12
....................  #define CAN_USER_FILT_12 0
.................... #endif
.................... #ifndef CAN_USER_FILT_13
....................  #define CAN_USER_FILT_13 0
.................... #endif
.................... #ifndef CAN_USER_FILT_14
....................  #define CAN_USER_FILT_14 0
.................... #endif
.................... #ifndef CAN_USER_FILT_15
....................  #define CAN_USER_FILT_15 0
.................... #endif
.................... 
.................... #if ((getenv("DEVICE") == "PIC18F25K83") || (getenv("DEVICE") == "PIC18LF25K83") || \
....................      (getenv("DEVICE") == "PIC18F26K83") || (getenv("DEVICE") == "PIC18LF26K83"))
....................  #ifndef CAN_RX_PIN
....................   #warning CAN RX pin not defined set to default pin, B3
....................  
....................   #define CAN_RX_PIN    PIN_B3
....................  #endif
....................  
....................  #pin_select CANRX = CAN_RX_PIN
....................  
....................  #ifndef CAN_TX_PIN
....................   #warning CAN TX pin not defined set to default pin, B2
....................   
....................   #define CAN_TX_PIN    PIN_B2
....................  #endif
....................  
....................  #pin_select CANTX0 = CAN_TX_PIN
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_init()
.................... //
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers
.................... // to only accept valid messages (as opposed to all messages, or all
.................... // extended message, or all standard messages).  Also sets the tri-state
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral
.................... // doesn't keep track of this)
.................... //
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH,
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file.
.................... // These default values can be overwritten in the main code, but most
.................... // applications will be fine with these defaults.
.................... //
.................... //////////////////////////////////////////////////////////////////////////////
.................... void can_init(void) {
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set
*
0928:  MOVLW  04
092A:  MOVWF  55
092C:  RCALL  08D8
....................    can_set_baud();
092E:  BRA    08FA
....................   
....................   #if !defined(CAN_FORCE_LEGACY_MODE)
....................    curfunmode=CAN_FUN_OP_LEGACY;
0930:  CLRF   1B
....................   #endif
.................... 
....................    // RXB0CON
....................    //    filthit0=0
....................    //    jtoff=0
....................    //      rxb0dben=1   buffer zero will overflow into buffer one
....................    //      rxrtrro=0
....................    //      rxm1:0=0      will receive all valid IDs
....................    RXB0CON=0;
0932:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID;
0934:  MOVLW  9F
0936:  ANDWF  F60,W
0938:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER;
093A:  BSF    F60.2
....................    RXB1CON=RXB0CON;
093C:  MOVFF  F60,F50
.................... 
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH;
0940:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE;
0942:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added for PIC18F6585/8585/6680/8680
0944:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added for PIC18F6585/8585/6680/8680
0946:  BCF    F73.6
0948:  CLRF   19
094A:  BTFSC  FF2.7
094C:  BSF    19.7
094E:  BCF    FF2.7
....................    
....................    can_set_id((unsigned int8*)RX0MASK, CAN_USER_MASK_0, CAN_USE_EXTENDED_ID);  //set mask 0
0950:  MOVLW  0F
0952:  MOVWF  x97
0954:  MOVLW  1B
0956:  MOVWF  x96
0958:  CLRF   x9B
095A:  CLRF   x9A
095C:  CLRF   x99
095E:  CLRF   x98
0960:  CLRF   x9C
0962:  RCALL  028E
0964:  BTFSC  19.7
0966:  BSF    FF2.7
0968:  CLRF   19
096A:  BTFSC  FF2.7
096C:  BSF    19.7
096E:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RX1MASK, CAN_USER_MASK_1, CAN_USE_EXTENDED_ID);  //set mask 1
0970:  MOVLW  0F
0972:  MOVWF  x97
0974:  MOVLW  1F
0976:  MOVWF  x96
0978:  CLRF   x9B
097A:  CLRF   x9A
097C:  CLRF   x99
097E:  CLRF   x98
0980:  CLRF   x9C
0982:  RCALL  028E
0984:  BTFSC  19.7
0986:  BSF    FF2.7
0988:  CLRF   19
098A:  BTFSC  FF2.7
098C:  BSF    19.7
098E:  BCF    FF2.7
....................    
....................   #if !defined(CAN_DONT_SET_FILTERS)
....................    can_set_id((unsigned int8*)RXFILTER0, CAN_USER_FILT_0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0
0990:  MOVLW  0F
0992:  MOVWF  x97
0994:  MOVLW  03
0996:  MOVWF  x96
0998:  CLRF   x9B
099A:  CLRF   x9A
099C:  CLRF   x99
099E:  CLRF   x98
09A0:  CLRF   x9C
09A2:  RCALL  028E
09A4:  BTFSC  19.7
09A6:  BSF    FF2.7
09A8:  CLRF   19
09AA:  BTFSC  FF2.7
09AC:  BSF    19.7
09AE:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER1, CAN_USER_FILT_1, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0
09B0:  MOVLW  0F
09B2:  MOVWF  x97
09B4:  MOVLW  07
09B6:  MOVWF  x96
09B8:  CLRF   x9B
09BA:  CLRF   x9A
09BC:  CLRF   x99
09BE:  CLRF   x98
09C0:  CLRF   x9C
09C2:  RCALL  028E
09C4:  BTFSC  19.7
09C6:  BSF    FF2.7
09C8:  CLRF   19
09CA:  BTFSC  FF2.7
09CC:  BSF    19.7
09CE:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER2, CAN_USER_FILT_2, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1
09D0:  MOVLW  0F
09D2:  MOVWF  x97
09D4:  MOVLW  0B
09D6:  MOVWF  x96
09D8:  CLRF   x9B
09DA:  CLRF   x9A
09DC:  CLRF   x99
09DE:  CLRF   x98
09E0:  CLRF   x9C
09E2:  RCALL  028E
09E4:  BTFSC  19.7
09E6:  BSF    FF2.7
09E8:  CLRF   19
09EA:  BTFSC  FF2.7
09EC:  BSF    19.7
09EE:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER3, CAN_USER_FILT_3, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1
09F0:  MOVLW  0F
09F2:  MOVWF  x97
09F4:  MOVWF  x96
09F6:  CLRF   x9B
09F8:  CLRF   x9A
09FA:  CLRF   x99
09FC:  CLRF   x98
09FE:  CLRF   x9C
0A00:  RCALL  028E
0A02:  BTFSC  19.7
0A04:  BSF    FF2.7
0A06:  CLRF   19
0A08:  BTFSC  FF2.7
0A0A:  BSF    19.7
0A0C:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER4, CAN_USER_FILT_4, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1
0A0E:  MOVLW  0F
0A10:  MOVWF  x97
0A12:  MOVLW  13
0A14:  MOVWF  x96
0A16:  CLRF   x9B
0A18:  CLRF   x9A
0A1A:  CLRF   x99
0A1C:  CLRF   x98
0A1E:  CLRF   x9C
0A20:  RCALL  028E
0A22:  BTFSC  19.7
0A24:  BSF    FF2.7
0A26:  CLRF   19
0A28:  BTFSC  FF2.7
0A2A:  BSF    19.7
0A2C:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER5, CAN_USER_FILT_5, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1
0A2E:  MOVLW  0F
0A30:  MOVWF  x97
0A32:  MOVLW  17
0A34:  MOVWF  x96
0A36:  CLRF   x9B
0A38:  CLRF   x9A
0A3A:  CLRF   x99
0A3C:  CLRF   x98
0A3E:  CLRF   x9C
0A40:  RCALL  028E
0A42:  BTFSC  19.7
0A44:  BSF    FF2.7
0A46:  CLRF   19
0A48:  BTFSC  FF2.7
0A4A:  BSF    19.7
0A4C:  BCF    FF2.7
....................    // set dynamic filters
....................    #if !defined(CAN_FORCE_LEGACY_MODE)
....................    can_set_id((unsigned int8*)RXFILTER6, CAN_USER_FILT_6, CAN_USE_EXTENDED_ID);
0A4E:  MOVLW  0D
0A50:  MOVWF  x97
0A52:  MOVLW  63
0A54:  MOVWF  x96
0A56:  CLRF   x9B
0A58:  CLRF   x9A
0A5A:  CLRF   x99
0A5C:  CLRF   x98
0A5E:  CLRF   x9C
0A60:  RCALL  028E
0A62:  BTFSC  19.7
0A64:  BSF    FF2.7
0A66:  CLRF   19
0A68:  BTFSC  FF2.7
0A6A:  BSF    19.7
0A6C:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER7, CAN_USER_FILT_7, CAN_USE_EXTENDED_ID);
0A6E:  MOVLW  0D
0A70:  MOVWF  x97
0A72:  MOVLW  67
0A74:  MOVWF  x96
0A76:  CLRF   x9B
0A78:  CLRF   x9A
0A7A:  CLRF   x99
0A7C:  CLRF   x98
0A7E:  CLRF   x9C
0A80:  RCALL  028E
0A82:  BTFSC  19.7
0A84:  BSF    FF2.7
0A86:  CLRF   19
0A88:  BTFSC  FF2.7
0A8A:  BSF    19.7
0A8C:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER8, CAN_USER_FILT_8, CAN_USE_EXTENDED_ID);
0A8E:  MOVLW  0D
0A90:  MOVWF  x97
0A92:  MOVLW  6B
0A94:  MOVWF  x96
0A96:  CLRF   x9B
0A98:  CLRF   x9A
0A9A:  CLRF   x99
0A9C:  CLRF   x98
0A9E:  CLRF   x9C
0AA0:  CALL   028E
0AA4:  BTFSC  19.7
0AA6:  BSF    FF2.7
0AA8:  CLRF   19
0AAA:  BTFSC  FF2.7
0AAC:  BSF    19.7
0AAE:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER9, CAN_USER_FILT_9, CAN_USE_EXTENDED_ID);
0AB0:  MOVLW  0D
0AB2:  MOVWF  x97
0AB4:  MOVLW  73
0AB6:  MOVWF  x96
0AB8:  CLRF   x9B
0ABA:  CLRF   x9A
0ABC:  CLRF   x99
0ABE:  CLRF   x98
0AC0:  CLRF   x9C
0AC2:  CALL   028E
0AC6:  BTFSC  19.7
0AC8:  BSF    FF2.7
0ACA:  CLRF   19
0ACC:  BTFSC  FF2.7
0ACE:  BSF    19.7
0AD0:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER10, CAN_USER_FILT_10, CAN_USE_EXTENDED_ID);
0AD2:  MOVLW  0D
0AD4:  MOVWF  x97
0AD6:  MOVLW  77
0AD8:  MOVWF  x96
0ADA:  CLRF   x9B
0ADC:  CLRF   x9A
0ADE:  CLRF   x99
0AE0:  CLRF   x98
0AE2:  CLRF   x9C
0AE4:  CALL   028E
0AE8:  BTFSC  19.7
0AEA:  BSF    FF2.7
0AEC:  CLRF   19
0AEE:  BTFSC  FF2.7
0AF0:  BSF    19.7
0AF2:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER11, CAN_USER_FILT_11, CAN_USE_EXTENDED_ID);
0AF4:  MOVLW  0D
0AF6:  MOVWF  x97
0AF8:  MOVLW  7B
0AFA:  MOVWF  x96
0AFC:  CLRF   x9B
0AFE:  CLRF   x9A
0B00:  CLRF   x99
0B02:  CLRF   x98
0B04:  CLRF   x9C
0B06:  CALL   028E
0B0A:  BTFSC  19.7
0B0C:  BSF    FF2.7
0B0E:  CLRF   19
0B10:  BTFSC  FF2.7
0B12:  BSF    19.7
0B14:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER12, CAN_USER_FILT_12, CAN_USE_EXTENDED_ID);
0B16:  MOVLW  0D
0B18:  MOVWF  x97
0B1A:  MOVLW  83
0B1C:  MOVWF  x96
0B1E:  CLRF   x9B
0B20:  CLRF   x9A
0B22:  CLRF   x99
0B24:  CLRF   x98
0B26:  CLRF   x9C
0B28:  CALL   028E
0B2C:  BTFSC  19.7
0B2E:  BSF    FF2.7
0B30:  CLRF   19
0B32:  BTFSC  FF2.7
0B34:  BSF    19.7
0B36:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER13, CAN_USER_FILT_13, CAN_USE_EXTENDED_ID);
0B38:  MOVLW  0D
0B3A:  MOVWF  x97
0B3C:  MOVLW  87
0B3E:  MOVWF  x96
0B40:  CLRF   x9B
0B42:  CLRF   x9A
0B44:  CLRF   x99
0B46:  CLRF   x98
0B48:  CLRF   x9C
0B4A:  CALL   028E
0B4E:  BTFSC  19.7
0B50:  BSF    FF2.7
0B52:  CLRF   19
0B54:  BTFSC  FF2.7
0B56:  BSF    19.7
0B58:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER14, CAN_USER_FILT_14, CAN_USE_EXTENDED_ID);
0B5A:  MOVLW  0D
0B5C:  MOVWF  x97
0B5E:  MOVLW  8B
0B60:  MOVWF  x96
0B62:  CLRF   x9B
0B64:  CLRF   x9A
0B66:  CLRF   x99
0B68:  CLRF   x98
0B6A:  CLRF   x9C
0B6C:  CALL   028E
0B70:  BTFSC  19.7
0B72:  BSF    FF2.7
0B74:  CLRF   19
0B76:  BTFSC  FF2.7
0B78:  BSF    19.7
0B7A:  BCF    FF2.7
....................    can_set_id((unsigned int8*)RXFILTER15, CAN_USER_FILT_15, CAN_USE_EXTENDED_ID);
0B7C:  MOVLW  0D
0B7E:  MOVWF  x97
0B80:  MOVLW  93
0B82:  MOVWF  x96
0B84:  CLRF   x9B
0B86:  CLRF   x9A
0B88:  CLRF   x99
0B8A:  CLRF   x98
0B8C:  CLRF   x9C
0B8E:  CALL   028E
0B92:  BTFSC  19.7
0B94:  BSF    FF2.7
....................    #endif
....................   #endif
.................... 
....................   #if (getenv("DEVICE") == "PIC18F6585") || (getenv("DEVICE") == "PIC18LF6585") || \
....................       (getenv("DEVICE") == "PIC18F6680") || (getenv("DEVICE") == "PIC18LF6680") || \
....................       (getenv("DEVICE") == "PIC18F8585") || (getenv("DEVICE") == "PIC18LF8585") || \
....................       (getenv("DEVICE") == "PIC18F8680") || (getenv("DEVICE") == "PIC18LF8680")
....................    set_tris_g((*getenv("SFR:TRISG") & 0xFE) | 0x04);  //G2 in, G0 out
....................    if(CAN_ENABLE_CANTX2)
....................     bit_clear(*getenv("SFR:TRISG"), 1);  //G1 out
....................   #elif getenv("FUSE_SET:CANE")
....................    set_tris_e((*getenv("SFR:TRISE") & 0xDF) | 0x10);  //E4 in, E5 out
....................   #elif getenv("FUSE_SET:CANC")
....................    set_tris_c((*getenv("SFR:TRISC") & 0xBF) | 0x80);  //C7 in, C6 out
....................   #elif !((getenv("DEVICE") == "PIC18F25K83") || (getenv("DEVICE") == "PIC18LF25K83") || \
....................           (getenv("DEVICE") == "PIC18F26K83") || (getenv("DEVICE") == "PIC18LF26K83"))
....................    set_tris_b((*getenv("SFR:TRISB") & 0xFB) | 0x08);  //B3 in, B2 out
0B96:  MOVF   F93,W
0B98:  ANDLW  FB
0B9A:  IORLW  08
0B9C:  MOVWF  F93
....................   #endif
....................   
....................   #if ((getenv("DEVICE") == "PIC18F25K83") || (getenv("DEVICE") == "PIC18LF25K83") || \
....................        (getenv("DEVICE") == "PIC18F26K83") || (getenv("DEVICE") == "PIC18LF26K83"))
....................    output_float(CAN_RX_PIN);
....................    output_drive(CAN_TX_PIN);     
....................   #endif
.................... 
....................    can_set_mode(CAN_OP_NORMAL);
0B9E:  CLRF   55
0BA0:  RCALL  08D8
0BA2:  GOTO   0C54 (RETURN)
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_set_baud()
.................... //
.................... // Configures the baud rate control registers.  All the defines here
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and
.................... // probably should, be overwritten in the main code.
.................... //
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN
.................... // Developers Kit if this PIC is running at 20Mhz.
.................... //
.................... //   BRGCON1 contains the prescaler bits and the Synchronization jump
.................... //         width time bits.
.................... //
.................... //           the prescale values are
.................... //              111111=(2*64)/clock=Tq
.................... //              111110=(2*63)/clock=Tq
.................... //                continued
.................... //              000001=(2*2)/clock=Tq
.................... //                000000=(2*1)/clock=Tq
.................... //
.................... //           in the case of can-18xxx8.h, the prescale bits are set to
.................... //           000100=10/clock provided that the user does not define it
.................... //           differently
.................... //
.................... //           The Synchronized Jump Width Bits are
.................... //              11=4*Tq
.................... //              10=3*Tq
.................... //              01=2*Tq
.................... //            00=1*Tq
.................... //
.................... //           in the case of can-18xxx8.h, the SJW bits are set to 0 or 1*Tq
.................... //
.................... //   BRGCON2 contains the Phase Segment 2 Time Select bit, the sample bit
.................... //          the Phase Segment 1 bits, and the Propagation Time Select bits
.................... //
.................... //           SEG2PHTS
.................... //                1=Freely Programmable
.................... //              0=Maximum of PHEG1 or IPT, which ever is greatest
.................... //
.................... //           in the case of can-18xxx8.h, the SEG2PHTS bit is set to 1 for
.................... //           freely programmable
.................... //
.................... //           SAM
.................... //              1=Three Samples
.................... //              0=One Sample
.................... //
.................... //           in the case of can-18xxx8.h, the SAM bit is set to 0 for
.................... //           one sample
.................... //
.................... //           SEG1PH2:SEG1PH0
.................... //              Phase Segment 1 = (SEG1PH2:SEG1PH0+1)*Tq
.................... //
.................... //           in the case of can-18xxx8.h, the SEG1PH2:SEG1PH0 bits are set to 5
.................... //         for 6*Tq Phase Segment 1 Time
.................... //
.................... //           PRSEG2:PRSEG0
.................... //              Propagation Time = (PRSEG2:PRSEG0+1)*TQ
.................... //
.................... //           in the case of can-18xxx8.h, the PRSEG2:PRSEG0 bits are set to 2
.................... //           for 3*Tq Propagation Time
.................... //
.................... // BRGCON3 contains the WAKFIL bit and the Phase Segment 2 Time Select bits
.................... //
.................... //           WAKEFIL
.................... //            1=CAN bus line filter is used for wake-up
.................... //              0=CAN bus line filter is not used for wake-up
.................... //
.................... //           in the case of can-18xx8.h, the WAKEFIL bit is set to 0 for
.................... //           CAN bus not used for wake-up
.................... //
.................... //           SEG2PH2:SEG2PH0
.................... //              Phase Segment 2 Time = (SEG2PH2:SEG2PH0+1)*Tq
.................... //
.................... //           in the case of can-18xxx8.h, SEG2PH2:SEG3PH0 is set to 5 for
.................... //         6*Tq Phase Segment 2 Time
.................... //
.................... // More information can be found in the PIC18F4580 datasheet section 23.9
.................... ////////////////////////////////////////////////////////////////////////
.................... void can_set_baud(void) {
....................    BRGCON1.brp=CAN_BRG_PRESCALAR;
*
08FA:  MOVLW  C0
08FC:  ANDWF  F70,W
08FE:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH;
0900:  MOVLW  3F
0902:  ANDWF  F70,W
0904:  IORLW  80
0906:  MOVWF  F70
.................... 
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME;
0908:  MOVLW  F8
090A:  ANDWF  F71,W
090C:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1;
090E:  MOVLW  C7
0910:  ANDWF  F71,W
0912:  IORLW  20
0914:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM;
0916:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS;
0918:  BSF    F71.7
.................... 
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2;
091A:  MOVLW  F8
091C:  ANDWF  F72,W
091E:  IORLW  02
0920:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER;
0922:  BSF    F72.6
0924:  GOTO   0930 (RETURN)
.................... }
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_set_mode
.................... //
.................... // This function first sets three most significant bits (reqop2:reqop0)
.................... // to the mode given through the argument.  The modes can be
.................... //
.................... // mode
.................... //
.................... // 1xx  -> Configuration Mode
.................... //             This mode allows the user to configure the Control Registers,
.................... //            the Acceptance Mask Registers and the Acceptance Filter
.................... //            Registers.
.................... //
.................... // 011  -> Listen Only Mode
.................... //            This mode allows the PIC microcontroller to listen to the
.................... //            bus but not actually write to it.
.................... //
.................... // 010  -> Loop Back Mode
.................... //            This mode allows to the transmission of data directly from
.................... //            the Transmission Buffers to the Receive Buffers without
.................... //            actually driving any data to the bus
.................... //
.................... // 001  -> Disable Mode
.................... //            This mode prevents the PIC microcontroller from transmitting
.................... //            and receiving, however the WAKIF interrupt is still active
.................... //
.................... // 000  -> Normal Mode
.................... //            This is the normal mode of operation for the CAN bus.  It
.................... //            will receive all messages and is the only mode in which
.................... //            data can be transmitted.
.................... //
.................... //   The reqop bits do not immediately change the mode of operation, the
.................... // three most significant bits in the CANSTAT register (opmode2:opmode0)
.................... // must change to reflect the actual change in mode, therefore a while
.................... // statement is used to check if the CANSTAT opmode bits have changed to
.................... // reflect the passed in mode
.................... //
.................... // More information can be found in the PIC18F4580 datasheet section 23.3
.................... ////////////////////////////////////////////////////////////////////////
.................... void can_set_mode(CAN_OP_MODE mode) {
....................    CANCON.reqop=mode;
*
08D8:  SWAPF  55,W
08DA:  ANDLW  70
08DC:  MOVWF  00
08DE:  BCF    FD8.0
08E0:  RLCF   00,F
08E2:  MOVLW  1F
08E4:  ANDWF  F6F,W
08E6:  IORWF  00,W
08E8:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode );
08EA:  MOVFF  F6E,00
08EE:  SWAPF  00,F
08F0:  RRCF   00,W
08F2:  ANDLW  07
08F4:  SUBWF  55,W
08F6:  BNZ   08EA
08F8:  RETURN 0
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_set_functional_mode
.................... //
.................... // This function sets the functional mode of the PIC18F4580 ECAN module
.................... //
.................... //   mode
.................... //
.................... // 00    -> mode 0 or Legacy Mode.  The processor defaults to this mode
.................... //            on reset in order to maintain backwards compatibility will
.................... //            the previous PIC18Cxx8 and PIC18Fxx8 CAN modules.  All code
.................... //            written for the listed microcontrollers will work on the
.................... //            PIC18F4580 will no alterations.
.................... //
.................... //            This mode provides the exact same registers as the previous
.................... //            modules.  These include
.................... //
.................... //            3 Transmit Buffers: TXB0, TXB1, TXB2
.................... //            2 Receive Buffers: RXB0, RXB1
.................... //            2 Acceptance Masks: RXM0, RXM1
.................... //            6 Acceptance Filters: RXF0, RXF1, RXF2, RXF3, RXF4, RXF5
.................... //
.................... // 01  -> mode 1 or Enhanced Legacy Mode. This mode is the same as mode
.................... //            0 with the exception that there are more resources available
.................... //            to the CAN module.  These include
.................... //
.................... //            3  Transmit Buffers: TXB0, TXB1, TXB2
.................... //            2  Receive Buffers: RXB0, RXB1
.................... //            6  Programmable Buffers: B0, B1, B2, B3, B4, B5
.................... //               Automatic RTR Handling on: B0, B1, B2, B3, B4, B5
.................... //            16 Dynamically assigned acceptance filters: RXF0-RXF15
.................... //            2  Dedicated mask registers,RXM0: RXM1
.................... //            1  Programmable mask register: RXF15
.................... //               Programmable data filter on standard identifier messages: SDFLC
.................... //
.................... // 10    -> mode 2 or Enhanced FIFO Mode.  This mode produces a first in
.................... //            first out (FIFO) CAN data buffer.  This buffer can be from 2 too
.................... //            8 bytes in length depending on which B buffers are used as receive
.................... //            buffers and which are used as transmit buffers.  The first transmit
.................... //            buffer defines the size, therefore if B4 was the first transmit
.................... //            buffer, RXB0, BXB1, B0, B1, B2, and B3 would form the FIFO buffer
.................... //            for a size of 6 bytes.  If B0 through B5 are all set to receive data,
.................... //            the size will be 8 bytes.  If B0 is set to transmit, the size will
.................... //            be 2 bytes.  The available resources include
.................... //
.................... //            3  Transmit Buffers: TXB0, TXB1, TXB2
.................... //            2  Receive Buffers: RXB0, RXB1
.................... //            6  Programmable Buffers: B0, B1, B2, B3, B4, B5
.................... //               Automatic RTR Handling on: B0, B1, B2, B3, B4, B5
.................... //            16 Acceptance Filters: RXF0-RXF15
.................... //            2  Dedicated Mask Registers: RXM0, RXM1
.................... //            1  Programmable mask register: RXF15
.................... //               Programmable data filter on standard identifier messages: SDFLC
.................... //
.................... //   More information can be found in the PIC18F4580 datasheet section 23.4
.................... ////////////////////////////////////////////////////////////////////////////////
.................... #if !defined(CAN_FORCE_LEGACY_MODE)
.................... void can_set_functional_mode(CAN_FUN_OP_MODE mode)
.................... {
....................    curmode=CANSTAT.opmode;
.................... 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set
....................    ECANCON.mdsel=mode;
....................    curfunmode=mode;
.................... 
....................    can_set_mode(curmode);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_set_id()
.................... //
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to
.................... // configure the defined buffer to use the specified ID
.................... //
.................... //   Parameters:
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL.
.................... //            For example, a pointer to RXM1EIDL
.................... //
.................... //     id - ID to set buffer to
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not
.................... //
.................... ////////////////////////////////////////////////////////////////////////
.................... void can_set_id(unsigned int8 *addr, unsigned int32 id, int1 ext) {
....................    //int *ptr;
.................... 
....................    //ptr=addr;
.................... 
....................    if (ext) {  //extended
*
028E:  MOVF   x9C,F
0290:  BZ    0336
....................       //eidl
....................       *addr=make8(id,0); //0:7
0292:  MOVFF  96,FE9
0296:  MOVFF  97,FEA
029A:  MOVFF  98,FEF
.................... 
....................       //eidh
....................       addr--;
029E:  MOVF   x96,W
02A0:  BTFSC  FD8.2
02A2:  DECF   x97,F
02A4:  DECF   x96,F
....................       *addr=make8(id,1); //8:15
02A6:  MOVFF  96,FE9
02AA:  MOVFF  97,FEA
02AE:  MOVFF  99,FEF
.................... 
....................       //sidl
....................       addr--;
02B2:  MOVF   x96,W
02B4:  BTFSC  FD8.2
02B6:  DECF   x97,F
02B8:  DECF   x96,F
....................       *addr=make8(id,2) & 0x03;   //16:17
02BA:  MOVFF  96,FE9
02BE:  MOVFF  97,FEA
02C2:  MOVF   x9A,W
02C4:  ANDLW  03
02C6:  MOVWF  FEF
....................       *addr|=(make8(id,2) << 3) & 0xE0; //18:20
02C8:  MOVFF  96,FE9
02CC:  MOVFF  97,FEA
02D0:  MOVFF  9A,00
02D4:  RLCF   00,F
02D6:  RLCF   00,F
02D8:  RLCF   00,F
02DA:  MOVLW  F8
02DC:  ANDWF  00,F
02DE:  MOVF   00,W
02E0:  ANDLW  E0
02E2:  IORWF  FEF,W
02E4:  MOVWF  FEF
....................       *addr|=0x08;
02E6:  MOVFF  96,FE9
02EA:  MOVFF  97,FEA
02EE:  MOVF   FEF,W
02F0:  IORLW  08
02F2:  MOVWF  FEF
.................... 
.................... 
....................       //sidh
....................       addr--;
02F4:  MOVF   x96,W
02F6:  BTFSC  FD8.2
02F8:  DECF   x97,F
02FA:  DECF   x96,F
....................       *addr=((make8(id,2) >> 5) & 0x07 ); //21:23
02FC:  MOVFF  96,FE9
0300:  MOVFF  97,FEA
0304:  MOVFF  9A,00
0308:  SWAPF  00,F
030A:  RRCF   00,F
030C:  MOVLW  07
030E:  ANDWF  00,F
0310:  MOVF   00,W
0312:  ANDLW  07
0314:  MOVWF  FEF
....................       *addr|=((make8(id,3) << 3) & 0xF8);//24:28
0316:  MOVFF  96,FE9
031A:  MOVFF  97,FEA
031E:  MOVFF  9B,00
0322:  RLCF   00,F
0324:  RLCF   00,F
0326:  RLCF   00,F
0328:  MOVLW  F8
032A:  ANDWF  00,F
032C:  MOVF   00,W
032E:  ANDLW  F8
0330:  IORWF  FEF,W
0332:  MOVWF  FEF
....................    }
0334:  BRA    03B4
....................    else {   //standard
....................       //eidl
....................       *addr=0;
0336:  MOVFF  96,FE9
033A:  MOVFF  97,FEA
033E:  CLRF   FEF
.................... 
....................       //eidh
....................       addr--;
0340:  MOVF   x96,W
0342:  BTFSC  FD8.2
0344:  DECF   x97,F
0346:  DECF   x96,F
....................       *addr=0;
0348:  MOVFF  96,FE9
034C:  MOVFF  97,FEA
0350:  CLRF   FEF
.................... 
....................       //sidl
....................       addr--;
0352:  MOVF   x96,W
0354:  BTFSC  FD8.2
0356:  DECF   x97,F
0358:  DECF   x96,F
....................       *addr=(make8(id,0) << 5) & 0xE0;
035A:  MOVFF  96,FE9
035E:  MOVFF  97,FEA
0362:  MOVFF  98,00
0366:  SWAPF  00,F
0368:  RLCF   00,F
036A:  MOVLW  E0
036C:  ANDWF  00,F
036E:  MOVF   00,W
0370:  ANDLW  E0
0372:  MOVWF  FEF
.................... 
....................       //sidh
....................       addr--;
0374:  MOVF   x96,W
0376:  BTFSC  FD8.2
0378:  DECF   x97,F
037A:  DECF   x96,F
....................       *addr=(make8(id,0) >> 3) & 0x1F;
037C:  MOVFF  96,FE9
0380:  MOVFF  97,FEA
0384:  MOVFF  98,00
0388:  RRCF   00,F
038A:  RRCF   00,F
038C:  RRCF   00,F
038E:  MOVLW  1F
0390:  ANDWF  00,F
0392:  MOVF   00,W
0394:  ANDLW  1F
0396:  MOVWF  FEF
....................       *addr|=(make8(id,1) << 5) & 0xE0;
0398:  MOVFF  96,FE9
039C:  MOVFF  97,FEA
03A0:  MOVFF  99,00
03A4:  SWAPF  00,F
03A6:  RLCF   00,F
03A8:  MOVLW  E0
03AA:  ANDWF  00,F
03AC:  MOVF   00,W
03AE:  ANDLW  E0
03B0:  IORWF  FEF,W
03B2:  MOVWF  FEF
....................    }
03B4:  RETURN 0
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_set_standard_id
.................... //
.................... // sets a standard id
.................... //
.................... // Parameters:
.................... //      addr - the address that is to be set to the id
.................... //      id - the actual id
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void can_set_standard_id(unsigned int8 *addr, unsigned int32 id)
.................... {
....................    //eidl
....................    *addr=0;
.................... 
....................    //eidh
....................    addr--;
....................    *addr=0;
.................... 
....................    //sidl
....................    addr--;
....................    *addr=(make8(id,0) << 5) & 0xE0;
.................... 
....................    //sidh
....................    addr--;
....................    *addr=(make8(id,0) >> 3) & 0x1F;
....................    *addr|=(make8(id,1) << 5) & 0xE0;
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_set_extended_id
.................... //
.................... // sets an extended id
.................... //
.................... // Parameters:
.................... //      addr - the address that is to be set to the id
.................... //      id - the actual id
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void can_set_extended_id(unsigned int8 *addr, unsigned int32 id)
.................... {
....................    //eidl
....................    *addr=make8(id,0); //0:7
.................... 
....................    //eidh
....................    addr--;
....................    *addr=make8(id,1); //8:15
.................... 
....................    //sidl
....................    addr--;
....................    *addr=make8(id,2) & 0x03;   //16:17
....................    *addr|=(make8(id,2) << 3) & 0xE0; //18:20
....................    *addr|=0x08;
.................... 
.................... 
....................    //sidh
....................    addr--;
....................    *addr=((make8(id,2) >> 5) & 0x07 ); //21:23
....................    *addr|=((make8(id,3) << 3) & 0xF8);//24:28
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_get_id()
.................... //
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id())
.................... // This is used after receiving a message, to see which ID sent the message.
.................... //
.................... //   Parameters:
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL.
.................... //            For example, a pointer to RXM1EIDL
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not
.................... //
.................... //   Returns:
.................... //     The ID of the buffer
.................... //
.................... ////////////////////////////////////////////////////////////////////////
.................... unsigned int32 can_get_id(unsigned int8 *addr, int1 ext) {
....................    unsigned int32 ret;
....................    unsigned int8 *ptr;
.................... 
....................    ret=0;
*
00AE:  CLRF   x9A
00B0:  CLRF   x99
00B2:  CLRF   x98
00B4:  CLRF   x97
....................    ptr=addr;
00B6:  MOVFF  95,9C
00BA:  MOVFF  94,9B
.................... 
....................    if (ext) {
00BE:  MOVF   x96,F
00C0:  BTFSC  FD8.2
00C2:  BRA    01D6
....................       ret=*ptr;  //eidl
00C4:  MOVFF  9B,FE9
00C8:  MOVFF  9C,FEA
00CC:  CLRF   x9A
00CE:  CLRF   x99
00D0:  CLRF   x98
00D2:  MOVFF  FEF,97
.................... 
....................       ptr--;     //eidh
00D6:  MOVF   x9B,W
00D8:  BTFSC  FD8.2
00DA:  DECF   x9C,F
00DC:  DECF   x9B,F
....................       ret|=((unsigned int32)*ptr << 8);
00DE:  MOVFF  9B,FE9
00E2:  MOVFF  9C,FEA
00E6:  MOVF   FEF,W
00E8:  CLRF   x9F
00EA:  CLRF   x9E
00EC:  MOVWF  x9D
00EE:  CLRF   00
00F0:  MOVF   00,W
00F2:  IORWF  x97,F
00F4:  MOVF   x9D,W
00F6:  IORWF  x98,F
00F8:  MOVF   x9E,W
00FA:  IORWF  x99,F
00FC:  MOVF   x9F,W
00FE:  IORWF  x9A,F
.................... 
....................       ptr--;     //sidl
0100:  MOVF   x9B,W
0102:  BTFSC  FD8.2
0104:  DECF   x9C,F
0106:  DECF   x9B,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16;
0108:  MOVFF  9B,FE9
010C:  MOVFF  9C,FEA
0110:  MOVF   FEF,W
0112:  CLRF   xA0
0114:  CLRF   x9F
0116:  CLRF   x9E
0118:  MOVWF  x9D
011A:  MOVLW  03
011C:  ANDWF  x9D,F
011E:  CLRF   x9E
0120:  CLRF   x9F
0122:  CLRF   xA0
0124:  CLRF   00
0126:  CLRF   01
0128:  MOVF   00,W
012A:  IORWF  x97,F
012C:  MOVF   01,W
012E:  IORWF  x98,F
0130:  MOVF   x9D,W
0132:  IORWF  x99,F
0134:  MOVF   x9E,W
0136:  IORWF  x9A,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13;
0138:  MOVFF  9B,FE9
013C:  MOVFF  9C,FEA
0140:  MOVF   FEF,W
0142:  CLRF   xA0
0144:  CLRF   x9F
0146:  CLRF   x9E
0148:  MOVWF  x9D
014A:  MOVLW  E0
014C:  ANDWF  x9D,F
014E:  CLRF   x9E
0150:  CLRF   x9F
0152:  CLRF   xA0
0154:  CLRF   00
0156:  RLCF   x9D,W
0158:  MOVWF  01
015A:  RLCF   x9E,W
015C:  MOVWF  02
015E:  RLCF   x9F,W
0160:  MOVWF  03
0162:  RLCF   01,F
0164:  RLCF   02,F
0166:  RLCF   03,F
0168:  RLCF   01,F
016A:  RLCF   02,F
016C:  RLCF   03,F
016E:  RLCF   01,F
0170:  RLCF   02,F
0172:  RLCF   03,F
0174:  RLCF   01,F
0176:  RLCF   02,F
0178:  RLCF   03,F
017A:  MOVLW  E0
017C:  ANDWF  01,F
017E:  MOVF   00,W
0180:  IORWF  x97,F
0182:  MOVF   01,W
0184:  IORWF  x98,F
0186:  MOVF   02,W
0188:  IORWF  x99,F
018A:  MOVF   03,W
018C:  IORWF  x9A,F
.................... 
....................       ptr--;     //sidh
018E:  MOVF   x9B,W
0190:  BTFSC  FD8.2
0192:  DECF   x9C,F
0194:  DECF   x9B,F
....................       ret|=((unsigned int32)*ptr << 21);
0196:  MOVFF  9B,FE9
019A:  MOVFF  9C,FEA
019E:  MOVF   FEF,W
01A0:  CLRF   x9E
01A2:  MOVWF  x9D
01A4:  CLRF   00
01A6:  CLRF   01
01A8:  RLCF   x9D,W
01AA:  MOVWF  02
01AC:  RLCF   x9E,W
01AE:  MOVWF  03
01B0:  RLCF   02,F
01B2:  RLCF   03,F
01B4:  RLCF   02,F
01B6:  RLCF   03,F
01B8:  RLCF   02,F
01BA:  RLCF   03,F
01BC:  RLCF   02,F
01BE:  RLCF   03,F
01C0:  MOVLW  E0
01C2:  ANDWF  02,F
01C4:  MOVF   00,W
01C6:  IORWF  x97,F
01C8:  MOVF   01,W
01CA:  IORWF  x98,F
01CC:  MOVF   02,W
01CE:  IORWF  x99,F
01D0:  MOVF   03,W
01D2:  IORWF  x9A,F
.................... 
....................    }
01D4:  BRA    027C
....................    else {
....................       ptr-=2;    //sidl
01D6:  MOVLW  02
01D8:  SUBWF  x9B,F
01DA:  MOVLW  00
01DC:  SUBWFB x9C,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5;
01DE:  MOVFF  9B,FE9
01E2:  MOVFF  9C,FEA
01E6:  MOVF   FEF,W
01E8:  CLRF   xA0
01EA:  CLRF   x9F
01EC:  CLRF   x9E
01EE:  MOVWF  x9D
01F0:  MOVLW  E0
01F2:  ANDWF  x9D,F
01F4:  CLRF   x9E
01F6:  CLRF   x9F
01F8:  CLRF   xA0
01FA:  RRCF   xA0,W
01FC:  MOVWF  x9A
01FE:  RRCF   x9F,W
0200:  MOVWF  x99
0202:  RRCF   x9E,W
0204:  MOVWF  x98
0206:  RRCF   x9D,W
0208:  MOVWF  x97
020A:  RRCF   x9A,F
020C:  RRCF   x99,F
020E:  RRCF   x98,F
0210:  RRCF   x97,F
0212:  RRCF   x9A,F
0214:  RRCF   x99,F
0216:  RRCF   x98,F
0218:  RRCF   x97,F
021A:  RRCF   x9A,F
021C:  RRCF   x99,F
021E:  RRCF   x98,F
0220:  RRCF   x97,F
0222:  RRCF   x9A,F
0224:  RRCF   x99,F
0226:  RRCF   x98,F
0228:  RRCF   x97,F
022A:  MOVLW  07
022C:  ANDWF  x9A,F
.................... 
....................       ptr--;     //sidh
022E:  MOVF   x9B,W
0230:  BTFSC  FD8.2
0232:  DECF   x9C,F
0234:  DECF   x9B,F
....................       ret|=((unsigned int32)*ptr << 3);
0236:  MOVFF  9B,FE9
023A:  MOVFF  9C,FEA
023E:  MOVF   FEF,W
0240:  CLRF   xA0
0242:  CLRF   x9F
0244:  CLRF   x9E
0246:  MOVWF  x9D
0248:  RLCF   x9D,W
024A:  MOVWF  00
024C:  RLCF   x9E,W
024E:  MOVWF  01
0250:  RLCF   x9F,W
0252:  MOVWF  02
0254:  RLCF   xA0,W
0256:  MOVWF  03
0258:  RLCF   00,F
025A:  RLCF   01,F
025C:  RLCF   02,F
025E:  RLCF   03,F
0260:  RLCF   00,F
0262:  RLCF   01,F
0264:  RLCF   02,F
0266:  RLCF   03,F
0268:  MOVLW  F8
026A:  ANDWF  00,F
026C:  MOVF   00,W
026E:  IORWF  x97,F
0270:  MOVF   01,W
0272:  IORWF  x98,F
0274:  MOVF   02,W
0276:  IORWF  x99,F
0278:  MOVF   03,W
027A:  IORWF  x9A,F
....................    }
.................... 
....................    return(ret);
027C:  MOVFF  97,00
0280:  MOVFF  98,01
0284:  MOVFF  99,02
0288:  MOVFF  9A,03
028C:  RETURN 0
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_get_extended_id
.................... //
.................... // reads the extended identification of a buffer
.................... //
.................... // Parameters:
.................... //      addr - the address that is to be read
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... unsigned int32 can_get_extended_id(unsigned int8 *addr)
.................... {
....................    unsigned int32 ret;
.................... 
....................    ret=*addr;  //eidl
.................... 
....................    addr--;     //eidh
....................    ret|=((unsigned int32)*addr << 8);
.................... 
....................    addr--;     //sidl
....................    ret|=((unsigned int32)*addr & 0x03) << 16;
....................    ret|=((unsigned int32)*addr & 0xE0) << 13;
.................... 
....................    addr--;     //sidh
....................    ret|=((unsigned int32)*addr << 21);
.................... 
....................    return (ret);
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_get_standard_id
.................... //
.................... // reads the standard identification of a buffer
.................... //
.................... // Parameters
.................... //      addr - the address that is to be read
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... unsigned int32 can_get_standard_id(unsigned int8 *addr)
.................... {
....................    unsigned int32 ret;
.................... 
....................    addr-=2;    //sidl
....................    ret=((unsigned int32)*addr & 0xE0) >> 5;
.................... 
....................    addr--;     //sidh
....................    ret|=((unsigned int32)*addr << 3);
.................... 
....................    return (ret);
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_putd()
.................... //
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will
.................... // send when the CAN bus becomes available.
.................... //
.................... //    Parameters:
.................... //       id - ID to transmit data as
.................... //          enumerated as - RXB0ID,RXB1ID,B0ID,B1ID,B2ID,B3ID,B4ID,B5ID
.................... //       data - pointer to data to send
.................... //       len - length of data to send
.................... //       priority - priority of message.  The higher the number, the
.................... //                  sooner the CAN peripheral will send the message.
.................... //                  Numbers 0 through 3 are valid.
.................... //       ext - TRUE to use an extended ID, FALSE if not
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT
.................... //
.................... //    Returns:
.................... //       If successful, it will return TRUE
.................... //       If un-successful, will return FALSE
.................... //
.................... ////////////////////////////////////////////////////////////////////////
.................... int1 can_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 priority, int1 ext, int1 rtr) {
....................    unsigned int8 i;
....................    unsigned int8 *txd0;
....................    unsigned int8 port;
.................... 
....................    txd0=&TXRXBaD0;
*
03B6:  MOVLW  0F
03B8:  MOVWF  x94
03BA:  MOVLW  66
03BC:  MOVWF  x93
.................... 
....................     // find empty transmitter
....................     // map access bank addresses to empty transmitter
....................   #if defined(CAN_FORCE_LEGACY_MODE)
....................    if (!TXB0CON.txreq)
....................    {
....................       CANCON.win=CAN_WIN_TX0;
....................       port=0;
....................    }
....................    else if (!TXB1CON.txreq)
....................    {
....................       CANCON.win=CAN_WIN_TX1;
....................       port=1;
....................    }
....................    else if (!TXB2CON.txreq)
....................    {
....................       CANCON.win=CAN_WIN_TX2;
....................       port=2;
....................    }  
....................   #else
....................    if (!TXB0CON.txreq)
03BE:  MOVLB  F
03C0:  BTFSC  x40.3
03C2:  BRA    03E2
....................    {
....................       if(curfunmode==CAN_FUN_OP_LEGACY)
03C4:  MOVF   1B,F
03C6:  BNZ   03D2
....................          CANCON.win=CAN_WIN_TX0;
03C8:  MOVLW  F1
03CA:  ANDWF  F6F,W
03CC:  IORLW  08
03CE:  MOVWF  F6F
03D0:  BRA    03DA
....................       else
....................          ECANCON.ewin=TX0;
03D2:  MOVLW  E0
03D4:  ANDWF  F77,W
03D6:  IORLW  03
03D8:  MOVWF  F77
....................       port=0;
03DA:  MOVLB  0
03DC:  CLRF   x95
....................    }
03DE:  BRA    04F2
03E0:  MOVLB  F
....................    else if (!TXB1CON.txreq)
03E2:  BTFSC  x30.3
03E4:  BRA    0406
....................    {
....................       if(curfunmode==CAN_FUN_OP_LEGACY)
03E6:  MOVF   1B,F
03E8:  BNZ   03F4
....................          CANCON.win=CAN_WIN_TX1;
03EA:  MOVLW  F1
03EC:  ANDWF  F6F,W
03EE:  IORLW  06
03F0:  MOVWF  F6F
03F2:  BRA    03FC
....................       else
....................          ECANCON.ewin=TX1;
03F4:  MOVLW  E0
03F6:  ANDWF  F77,W
03F8:  IORLW  04
03FA:  MOVWF  F77
....................       port=1;
03FC:  MOVLW  01
03FE:  MOVLB  0
0400:  MOVWF  x95
....................    }
0402:  BRA    04F2
0404:  MOVLB  F
....................    else if (!TXB2CON.txreq)
0406:  BTFSC  x20.3
0408:  BRA    0428
....................    {
....................       if(curfunmode==CAN_FUN_OP_LEGACY)
040A:  MOVF   1B,F
040C:  BNZ   0418
....................          CANCON.win=CAN_WIN_TX2;
040E:  MOVLW  F1
0410:  ANDWF  F6F,W
0412:  IORLW  04
0414:  MOVWF  F6F
0416:  BRA    0420
....................       else
....................          ECANCON.ewin=TX2;
0418:  MOVLW  E0
041A:  ANDWF  F77,W
041C:  IORLW  05
041E:  MOVWF  F77
....................       port=2;
0420:  MOVLW  02
0422:  MOVLB  0
0424:  MOVWF  x95
....................    }
0426:  BRA    04F2
....................    else if (!B0CONT.txreq && BSEL0.b0txen)
0428:  MOVLB  E
042A:  BTFSC  x20.3
042C:  BRA    044A
042E:  MOVLB  D
0430:  BTFSC  xF8.2
0432:  BRA    0438
0434:  MOVLB  E
0436:  BRA    044A
....................    {
....................       ECANCON.ewin=TXRX0;
0438:  MOVLW  E0
043A:  ANDWF  F77,W
043C:  IORLW  12
043E:  MOVWF  F77
....................       port=3;
0440:  MOVLW  03
0442:  MOVLB  0
0444:  MOVWF  x95
....................    }
0446:  BRA    04F2
0448:  MOVLB  E
....................    else if (!B1CONT.txreq && BSEL0.b1txen)
044A:  BTFSC  x30.3
044C:  BRA    046A
044E:  MOVLB  D
0450:  BTFSC  xF8.3
0452:  BRA    0458
0454:  MOVLB  E
0456:  BRA    046A
....................    {
....................       ECANCON.ewin=TXRX1;
0458:  MOVLW  E0
045A:  ANDWF  F77,W
045C:  IORLW  13
045E:  MOVWF  F77
....................       port=4;
0460:  MOVLW  04
0462:  MOVLB  0
0464:  MOVWF  x95
....................    }
0466:  BRA    04F2
0468:  MOVLB  E
....................    else if (!B2CONT.txreq && BSEL0.b2txen)
046A:  BTFSC  x40.3
046C:  BRA    048A
046E:  MOVLB  D
0470:  BTFSC  xF8.4
0472:  BRA    0478
0474:  MOVLB  E
0476:  BRA    048A
....................    {
....................       ECANCON.ewin=TXRX2;
0478:  MOVLW  E0
047A:  ANDWF  F77,W
047C:  IORLW  14
047E:  MOVWF  F77
....................       port=5;
0480:  MOVLW  05
0482:  MOVLB  0
0484:  MOVWF  x95
....................    }
0486:  BRA    04F2
0488:  MOVLB  E
....................    else if (!B3CONT.txreq && BSEL0.b3txen)
048A:  BTFSC  x50.3
048C:  BRA    04AA
048E:  MOVLB  D
0490:  BTFSC  xF8.5
0492:  BRA    0498
0494:  MOVLB  E
0496:  BRA    04AA
....................    {
....................       ECANCON.ewin=TXRX3;
0498:  MOVLW  E0
049A:  ANDWF  F77,W
049C:  IORLW  15
049E:  MOVWF  F77
....................       port=6;
04A0:  MOVLW  06
04A2:  MOVLB  0
04A4:  MOVWF  x95
....................    }
04A6:  BRA    04F2
04A8:  MOVLB  E
....................    else if (!B4CONT.txreq && BSEL0.b4txen)
04AA:  BTFSC  x60.3
04AC:  BRA    04CA
04AE:  MOVLB  D
04B0:  BTFSC  xF8.6
04B2:  BRA    04B8
04B4:  MOVLB  E
04B6:  BRA    04CA
....................    {
....................       ECANCON.ewin=TXRX4;
04B8:  MOVLW  E0
04BA:  ANDWF  F77,W
04BC:  IORLW  16
04BE:  MOVWF  F77
....................       port=7;
04C0:  MOVLW  07
04C2:  MOVLB  0
04C4:  MOVWF  x95
....................    }
04C6:  BRA    04F2
04C8:  MOVLB  E
....................    else if (!B5CONT.txreq && BSEL0.b5txen)
04CA:  BTFSC  x70.3
04CC:  BRA    04EA
04CE:  MOVLB  D
04D0:  BTFSC  xF8.7
04D2:  BRA    04D8
04D4:  MOVLB  E
04D6:  BRA    04EA
....................    {
....................       ECANCON.ewin=TXRX5;
04D8:  MOVLW  E0
04DA:  ANDWF  F77,W
04DC:  IORLW  17
04DE:  MOVWF  F77
....................       port=8;
04E0:  MOVLW  08
04E2:  MOVLB  0
04E4:  MOVWF  x95
....................    }
....................   #endif
04E6:  BRA    04F2
04E8:  MOVLB  E
....................    else
....................    {
....................       #if CAN_DO_DEBUG
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n");
....................       #endif
....................       return(0);
04EA:  MOVLW  00
04EC:  MOVWF  01
04EE:  BRA    0574
04F0:  MOVLB  0
....................    }
.................... 
....................    //set priority.
....................    TXBaCON.txpri=priority;
04F2:  MOVF   x8F,W
04F4:  ANDLW  03
04F6:  MOVWF  00
04F8:  MOVLW  FC
04FA:  ANDWF  F60,W
04FC:  IORWF  00,W
04FE:  MOVWF  F60
.................... 
....................    //set tx mask
....................    can_set_id((unsigned int8*)TXRXBaID, id, ext);
0500:  MOVLW  0F
0502:  MOVWF  x97
0504:  MOVLW  64
0506:  MOVWF  x96
0508:  MOVFF  8B,9B
050C:  MOVFF  8A,9A
0510:  MOVFF  89,99
0514:  MOVFF  88,98
0518:  MOVFF  90,9C
051C:  RCALL  028E
.................... 
....................    //set tx data count
....................    TXBaDLC=len;
051E:  MOVFF  8E,F65
....................    TXBaDLC.rtr=rtr;
0522:  BCF    F65.6
0524:  BTFSC  x91.0
0526:  BSF    F65.6
.................... 
....................     for (i=0; i<len; i++) {
0528:  CLRF   x92
052A:  MOVF   x8E,W
052C:  SUBWF  x92,W
052E:  BC    0558
....................       *txd0=*data;
0530:  MOVFF  8C,FE9
0534:  MOVFF  8D,FEA
0538:  MOVFF  FEF,98
053C:  MOVFF  94,FEA
0540:  MOVFF  93,FE9
0544:  MOVFF  98,FEF
....................       txd0++;
0548:  INCF   x93,F
054A:  BTFSC  FD8.2
054C:  INCF   x94,F
....................       data++;
054E:  INCF   x8C,F
0550:  BTFSC  FD8.2
0552:  INCF   x8D,F
0554:  INCF   x92,F
0556:  BRA    052A
....................     }
.................... 
....................    //enable transmission
....................    TXBaCON.txreq=1;
0558:  BSF    F60.3
....................    
....................   #if defined(CAN_FORCE_LEGACY_MODE)
....................    CANCON.win=CAN_WIN_RX0;
....................   #else
....................    if(curfunmode==CAN_FUN_OP_LEGACY)
055A:  MOVF   1B,F
055C:  BNZ   0566
....................       CANCON.win=CAN_WIN_RX0;
055E:  MOVLW  F1
0560:  ANDWF  F6F,W
0562:  MOVWF  F6F
0564:  BRA    056E
....................    else
....................       ECANCON.ewin=RX0;
0566:  MOVLW  E0
0568:  ANDWF  F77,W
056A:  IORLW  10
056C:  MOVWF  F77
....................   #endif
.................... 
....................    #if CAN_DO_DEBUG
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr);
....................             if ((len)&&(!rtr)) {
....................                data-=len;
....................                can_debug("  DATA = ");
....................                for (i=0;i<len;i++) {
....................                   can_debug("%X ",*data);
....................                   data++;
....................                }
....................                can_debug("\r\n");
....................             }
....................    #endif
.................... 
....................    return(1);
056E:  MOVLW  01
0570:  MOVWF  01
0572:  MOVLB  E
0574:  MOVLB  0
0576:  RETURN 0
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_getd()
.................... //
.................... // Gets data from a receive buffer, if the data exists
.................... //
.................... //    Parameters:
.................... //      id - ID who sent message
.................... //      data - pointer to array of data
.................... //      len - length of received data
.................... //      stat - structure holding some information (such as which buffer
.................... //             received it, ext or standard, etc)
.................... //
.................... //    Returns:
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE
.................... //      if there was none.
.................... //
.................... ////////////////////////////////////////////////////////////////////////
.................... int1 can_getd(unsigned int32 &id, unsigned int8 *data, unsigned int8 &len, struct rx_stat &stat)
.................... {
....................    unsigned int8 i;
....................    unsigned int8 *ptr;
.................... 
....................   #if defined(CAN_FORCE_LEGACY_MODE)
....................     if (RXB0CON.rxful) {
....................         CANCON.win=CAN_WIN_RX0;
....................         stat.buffer=0;
.................... 
....................         //CAN_INT_RXB0IF=0;
.................... 
....................         stat.err_ovfl=COMSTAT.rx0ovfl;
....................         COMSTAT.rx0ovfl=0;
.................... 
....................         if (RXB0CON.rxb0dben) {
....................          stat.filthit=RXB0CON.filthit0;
....................         }
....................     }
....................     else if ( RXB1CON.rxful )
....................     {
....................         CANCON.win=CAN_WIN_RX1;
....................         stat.buffer=1;
.................... 
....................         //CAN_INT_RXB1IF=0;
.................... 
....................         stat.err_ovfl=COMSTAT.rx1ovfl;
....................         COMSTAT.rx1ovfl=0;
.................... 
....................         stat.filthit=RXB1CON.filthit;
....................     }  
....................   #else
....................    if (RXB0CON.rxful)
*
059C:  BTFSS  F60.7
059E:  BRA    05DE
*
0CDA:  BTFSS  F60.7
0CDC:  BRA    0D1C
....................    {
....................       if(curfunmode==CAN_FUN_OP_LEGACY)
*
05A0:  MOVF   1B,F
05A2:  BNZ   05AC
*
0CDE:  MOVF   1B,F
0CE0:  BNZ   0CEA
....................          CANCON.win=CAN_WIN_RX0;
*
05A4:  MOVLW  F1
05A6:  ANDWF  F6F,W
05A8:  MOVWF  F6F
05AA:  BRA    05B4
*
0CE2:  MOVLW  F1
0CE4:  ANDWF  F6F,W
0CE6:  MOVWF  F6F
0CE8:  BRA    0CF2
....................       else
....................          ECANCON.ewin=RX0;          // this is if in functional mode 1 or 2
*
05AC:  MOVLW  E0
05AE:  ANDWF  F77,W
05B0:  IORLW  10
05B2:  MOVWF  F77
*
0CEA:  MOVLW  E0
0CEC:  ANDWF  F77,W
0CEE:  IORLW  10
0CF0:  MOVWF  F77
.................... 
....................       stat.buffer=0;
*
05B4:  CLRF   x7E
*
0CF2:  CLRF   53
.................... 
....................       //CAN_INT_RXB0IF=0;           // moved to end of function
.................... 
....................       if(curfunmode)
*
05B6:  MOVF   1B,F
05B8:  BZ    05CA
*
0CF4:  MOVF   1B,F
0CF6:  BZ    0D08
....................       {
....................          stat.err_ovfl=COMSTAT_MODE_1.rxnovfl;
*
05BA:  BCF    x7C.0
05BC:  BTFSC  F74.6
05BE:  BSF    x7C.0
*
0CF8:  BCF    51.0
0CFA:  BTFSC  F74.6
0CFC:  BSF    51.0
....................          COMSTAT_MODE_1.rxnovfl = 0;
*
05C0:  BCF    F74.6
*
0CFE:  BCF    F74.6
....................          stat.filthit=RXB0CON_MODE_1.filthit;
*
05C2:  MOVF   F60,W
05C4:  ANDLW  1F
05C6:  MOVWF  x7D
*
0D00:  MOVF   F60,W
0D02:  ANDLW  1F
0D04:  MOVWF  52
....................       }
*
05C8:  BRA    05DC
*
0D06:  BRA    0D1A
....................       else
....................       {
....................          stat.err_ovfl=COMSTAT.rx0ovfl;
*
05CA:  BCF    x7C.0
05CC:  BTFSC  F74.7
05CE:  BSF    x7C.0
*
0D08:  BCF    51.0
0D0A:  BTFSC  F74.7
0D0C:  BSF    51.0
....................          COMSTAT.rx0ovfl=0;
*
05D0:  BCF    F74.7
*
0D0E:  BCF    F74.7
.................... 
....................          if (RXB0CON.rxb0dben)
*
05D2:  BTFSS  F60.2
05D4:  BRA    05DC
*
0D10:  BTFSS  F60.2
0D12:  BRA    0D1A
....................          {
....................             stat.filthit=RXB0CON.filthit0;
*
05D6:  CLRF   x7D
05D8:  BTFSC  F60.0
05DA:  INCF   x7D,F
*
0D14:  CLRF   52
0D16:  BTFSC  F60.0
0D18:  INCF   52,F
....................          }
....................       }
....................    }
*
05DC:  BRA    0762
*
0D1A:  BRA    0E72
....................    else if ( RXB1CON.rxful )
*
05DE:  MOVLB  F
05E0:  BTFSS  x50.7
05E2:  BRA    062C
*
0D1C:  MOVLB  F
0D1E:  BTFSS  x50.7
0D20:  BRA    0D60
....................    {
....................       if(curfunmode==CAN_FUN_OP_LEGACY)
*
05E4:  MOVF   1B,F
05E6:  BNZ   05F2
*
0D22:  MOVF   1B,F
0D24:  BNZ   0D30
....................          CANCON.win=CAN_WIN_RX1;
*
05E8:  MOVLW  F1
05EA:  ANDWF  F6F,W
05EC:  IORLW  0A
05EE:  MOVWF  F6F
05F0:  BRA    05FA
*
0D26:  MOVLW  F1
0D28:  ANDWF  F6F,W
0D2A:  IORLW  0A
0D2C:  MOVWF  F6F
0D2E:  BRA    0D38
....................       else
....................          ECANCON.ewin=RX1;
*
05F2:  MOVLW  E0
05F4:  ANDWF  F77,W
05F6:  IORLW  11
05F8:  MOVWF  F77
*
0D30:  MOVLW  E0
0D32:  ANDWF  F77,W
0D34:  IORLW  11
0D36:  MOVWF  F77
.................... 
....................       stat.buffer=1;
*
05FA:  MOVLW  01
05FC:  MOVLB  0
05FE:  MOVWF  x7E
*
0D38:  MOVLW  01
0D3A:  MOVWF  53
.................... 
....................       //CAN_INT_RXB1IF=0;           //moved to end of function
.................... 
....................       if(curfunmode)
*
0600:  MOVF   1B,F
0602:  BZ    0618
*
0D3C:  MOVF   1B,F
0D3E:  BZ    0D50
....................       {
....................          stat.err_ovfl=COMSTAT_MODE_1.rxnovfl;
*
0604:  BCF    x7C.0
0606:  BTFSC  F74.6
0608:  BSF    x7C.0
*
0D40:  BCF    51.0
0D42:  BTFSC  F74.6
0D44:  BSF    51.0
....................          COMSTAT_MODE_1.rxnovfl = 0;
*
060A:  BCF    F74.6
*
0D46:  BCF    F74.6
....................          stat.filthit=RXB1CON_MODE_1.filthit;
*
060C:  MOVLB  F
060E:  MOVF   x50,W
0610:  ANDLW  1F
0612:  MOVLB  0
0614:  MOVWF  x7D
*
0D48:  MOVF   x50,W
0D4A:  ANDLW  1F
0D4C:  MOVWF  52
....................       }
*
0616:  BRA    062A
*
0D4E:  BRA    0D5E
....................       else
....................       {
....................          stat.err_ovfl=COMSTAT.rx1ovfl;
*
0618:  BCF    x7C.0
061A:  BTFSC  F74.6
061C:  BSF    x7C.0
*
0D50:  BCF    51.0
0D52:  BTFSC  F74.6
0D54:  BSF    51.0
....................          COMSTAT.rx1ovfl=0;
*
061E:  BCF    F74.6
*
0D56:  BCF    F74.6
.................... 
....................          stat.filthit=RXB1CON.filthit;
*
0620:  MOVLB  F
0622:  MOVF   x50,W
0624:  ANDLW  07
0626:  MOVLB  0
0628:  MOVWF  x7D
*
0D58:  MOVF   x50,W
0D5A:  ANDLW  07
0D5C:  MOVWF  52
....................       }
....................    }
*
062A:  BRA    0762
*
0D5E:  BRA    0E70
....................    else if (B0CONR.rxful && !BSEL0.b0txen)
*
062C:  MOVLB  E
062E:  BTFSS  x20.7
0630:  BRA    0660
0632:  MOVLB  D
0634:  BTFSS  xF8.2
0636:  BRA    063C
0638:  MOVLB  E
063A:  BRA    0660
*
0D60:  MOVLB  E
0D62:  BTFSS  x20.7
0D64:  BRA    0D8E
0D66:  MOVLB  D
0D68:  BTFSS  xF8.2
0D6A:  BRA    0D70
0D6C:  MOVLB  E
0D6E:  BRA    0D8E
....................    {
....................       ECANCON.ewin=TXRX0;
*
063C:  MOVLW  E0
063E:  ANDWF  F77,W
0640:  IORLW  12
0642:  MOVWF  F77
*
0D70:  MOVLW  E0
0D72:  ANDWF  F77,W
0D74:  IORLW  12
0D76:  MOVWF  F77
....................       stat.buffer=2;
*
0644:  MOVLW  02
0646:  MOVLB  0
0648:  MOVWF  x7E
*
0D78:  MOVLW  02
0D7A:  MOVWF  53
.................... 
....................       //CAN_INT_RXB1IF=0;         //moved to end of function
.................... 
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl;
*
064A:  BCF    x7C.0
064C:  BTFSC  F74.6
064E:  BSF    x7C.0
*
0D7C:  BCF    51.0
0D7E:  BTFSC  F74.6
0D80:  BSF    51.0
....................       COMSTAT_MODE_1.rxnovfl = 0;
*
0650:  BCF    F74.6
*
0D82:  BCF    F74.6
....................       stat.filthit=B0CONR.filhit;
*
0652:  MOVLB  E
0654:  MOVF   x20,W
0656:  ANDLW  1F
0658:  MOVLB  0
065A:  MOVWF  x7D
*
0D84:  MOVLB  E
0D86:  MOVF   x20,W
0D88:  ANDLW  1F
0D8A:  MOVWF  52
.................... 
....................      // B0CONR.rxful=0;          //moved to end of function because this shouldn't be
....................                                  //cleared until after data has been retrieved from buffer
....................    }
*
065C:  BRA    0762
065E:  MOVLB  E
*
0D8C:  BRA    0E70
....................    else if (B1CONR.rxful && !BSEL0.b1txen)
*
0660:  BTFSS  x30.7
0662:  BRA    0692
0664:  MOVLB  D
0666:  BTFSS  xF8.3
0668:  BRA    066E
066A:  MOVLB  E
066C:  BRA    0692
*
0D8E:  BTFSS  x30.7
0D90:  BRA    0DBA
0D92:  MOVLB  D
0D94:  BTFSS  xF8.3
0D96:  BRA    0D9C
0D98:  MOVLB  E
0D9A:  BRA    0DBA
....................    {
....................       ECANCON.ewin=TXRX1;
*
066E:  MOVLW  E0
0670:  ANDWF  F77,W
0672:  IORLW  13
0674:  MOVWF  F77
*
0D9C:  MOVLW  E0
0D9E:  ANDWF  F77,W
0DA0:  IORLW  13
0DA2:  MOVWF  F77
....................       stat.buffer=3;
*
0676:  MOVLW  03
0678:  MOVLB  0
067A:  MOVWF  x7E
*
0DA4:  MOVLW  03
0DA6:  MOVWF  53
.................... 
....................       //CAN_INT_RXB1IF=0;         //moved to end of function
.................... 
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl;
*
067C:  BCF    x7C.0
067E:  BTFSC  F74.6
0680:  BSF    x7C.0
*
0DA8:  BCF    51.0
0DAA:  BTFSC  F74.6
0DAC:  BSF    51.0
....................       COMSTAT_MODE_1.rxnovfl = 0;
*
0682:  BCF    F74.6
*
0DAE:  BCF    F74.6
....................       stat.filthit=B1CONR.filhit;
*
0684:  MOVLB  E
0686:  MOVF   x30,W
0688:  ANDLW  1F
068A:  MOVLB  0
068C:  MOVWF  x7D
*
0DB0:  MOVLB  E
0DB2:  MOVF   x30,W
0DB4:  ANDLW  1F
0DB6:  MOVWF  52
.................... 
....................       //B1CONR.rxful=0;          //moved to end of function because this shouldn't be
....................                                  //cleared until after data has been retrieved from buffer
....................    }
*
068E:  BRA    0762
0690:  MOVLB  E
*
0DB8:  BRA    0E70
....................    else if (B2CONR.rxful && !BSEL0.b2txen)
*
0692:  BTFSS  x40.7
0694:  BRA    06C4
0696:  MOVLB  D
0698:  BTFSS  xF8.4
069A:  BRA    06A0
069C:  MOVLB  E
069E:  BRA    06C4
*
0DBA:  BTFSS  x40.7
0DBC:  BRA    0DE6
0DBE:  MOVLB  D
0DC0:  BTFSS  xF8.4
0DC2:  BRA    0DC8
0DC4:  MOVLB  E
0DC6:  BRA    0DE6
....................    {
....................       ECANCON.ewin=TXRX2;
*
06A0:  MOVLW  E0
06A2:  ANDWF  F77,W
06A4:  IORLW  14
06A6:  MOVWF  F77
*
0DC8:  MOVLW  E0
0DCA:  ANDWF  F77,W
0DCC:  IORLW  14
0DCE:  MOVWF  F77
....................       stat.buffer=4;
*
06A8:  MOVLW  04
06AA:  MOVLB  0
06AC:  MOVWF  x7E
*
0DD0:  MOVLW  04
0DD2:  MOVWF  53
.................... 
....................       //CAN_INT_RXB1IF=0;         //moved to end of function
.................... 
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl;
*
06AE:  BCF    x7C.0
06B0:  BTFSC  F74.6
06B2:  BSF    x7C.0
*
0DD4:  BCF    51.0
0DD6:  BTFSC  F74.6
0DD8:  BSF    51.0
....................       COMSTAT_MODE_1.rxnovfl = 0;
*
06B4:  BCF    F74.6
*
0DDA:  BCF    F74.6
....................       stat.filthit=B2CONR.filhit;
*
06B6:  MOVLB  E
06B8:  MOVF   x40,W
06BA:  ANDLW  1F
06BC:  MOVLB  0
06BE:  MOVWF  x7D
*
0DDC:  MOVLB  E
0DDE:  MOVF   x40,W
0DE0:  ANDLW  1F
0DE2:  MOVWF  52
.................... 
....................       //B2CONR.rxful=0;          //moved to end of function because this shouldn't be
....................                                  //cleared until after data has been retrieved from buffer
....................    }
*
06C0:  BRA    0762
06C2:  MOVLB  E
*
0DE4:  BRA    0E70
....................    else if (B3CONR.rxful && !BSEL0.b3txen)
*
06C4:  BTFSS  x50.7
06C6:  BRA    06F6
06C8:  MOVLB  D
06CA:  BTFSS  xF8.5
06CC:  BRA    06D2
06CE:  MOVLB  E
06D0:  BRA    06F6
*
0DE6:  BTFSS  x50.7
0DE8:  BRA    0E12
0DEA:  MOVLB  D
0DEC:  BTFSS  xF8.5
0DEE:  BRA    0DF4
0DF0:  MOVLB  E
0DF2:  BRA    0E12
....................    {
....................       ECANCON.ewin=TXRX3;
*
06D2:  MOVLW  E0
06D4:  ANDWF  F77,W
06D6:  IORLW  15
06D8:  MOVWF  F77
*
0DF4:  MOVLW  E0
0DF6:  ANDWF  F77,W
0DF8:  IORLW  15
0DFA:  MOVWF  F77
....................       stat.buffer=5;
*
06DA:  MOVLW  05
06DC:  MOVLB  0
06DE:  MOVWF  x7E
*
0DFC:  MOVLW  05
0DFE:  MOVWF  53
.................... 
....................       //CAN_INT_RXB1IF=0;         //moved to end of function
.................... 
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl;
*
06E0:  BCF    x7C.0
06E2:  BTFSC  F74.6
06E4:  BSF    x7C.0
*
0E00:  BCF    51.0
0E02:  BTFSC  F74.6
0E04:  BSF    51.0
....................       COMSTAT_MODE_1.rxnovfl = 0;
*
06E6:  BCF    F74.6
*
0E06:  BCF    F74.6
....................       stat.filthit=B3CONR.filhit;
*
06E8:  MOVLB  E
06EA:  MOVF   x50,W
06EC:  ANDLW  1F
06EE:  MOVLB  0
06F0:  MOVWF  x7D
*
0E08:  MOVLB  E
0E0A:  MOVF   x50,W
0E0C:  ANDLW  1F
0E0E:  MOVWF  52
.................... 
....................       //B3CONR.rxful=0;          //moved to end of function because this shouldn't be
....................                                  //cleared until after data has been retrieved from buffer
....................    }
*
06F2:  BRA    0762
06F4:  MOVLB  E
*
0E10:  BRA    0E70
....................    else if (B4CONR.rxful && !BSEL0.b4txen)
*
06F6:  BTFSS  x60.7
06F8:  BRA    0728
06FA:  MOVLB  D
06FC:  BTFSS  xF8.6
06FE:  BRA    0704
0700:  MOVLB  E
0702:  BRA    0728
*
0E12:  BTFSS  x60.7
0E14:  BRA    0E3E
0E16:  MOVLB  D
0E18:  BTFSS  xF8.6
0E1A:  BRA    0E20
0E1C:  MOVLB  E
0E1E:  BRA    0E3E
....................    {
....................       ECANCON.ewin=TXRX4;
*
0704:  MOVLW  E0
0706:  ANDWF  F77,W
0708:  IORLW  16
070A:  MOVWF  F77
*
0E20:  MOVLW  E0
0E22:  ANDWF  F77,W
0E24:  IORLW  16
0E26:  MOVWF  F77
....................       stat.buffer=6;
*
070C:  MOVLW  06
070E:  MOVLB  0
0710:  MOVWF  x7E
*
0E28:  MOVLW  06
0E2A:  MOVWF  53
.................... 
....................       //CAN_INT_RXB1IF=0;         //moved to end of function
.................... 
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl;
*
0712:  BCF    x7C.0
0714:  BTFSC  F74.6
0716:  BSF    x7C.0
*
0E2C:  BCF    51.0
0E2E:  BTFSC  F74.6
0E30:  BSF    51.0
....................       COMSTAT_MODE_1.rxnovfl = 0;
*
0718:  BCF    F74.6
*
0E32:  BCF    F74.6
....................       stat.filthit=B4CONR.filhit;
*
071A:  MOVLB  E
071C:  MOVF   x60,W
071E:  ANDLW  1F
0720:  MOVLB  0
0722:  MOVWF  x7D
*
0E34:  MOVLB  E
0E36:  MOVF   x60,W
0E38:  ANDLW  1F
0E3A:  MOVWF  52
.................... 
....................       //B4CONR.rxful=0;          //moved to end of function because this shouldn't be
....................                                  //cleared until after data has been retrieved from buffer
....................    }
*
0724:  BRA    0762
0726:  MOVLB  E
*
0E3C:  BRA    0E70
....................    else if (B5CONR.rxful && !BSEL0.b5txen)
*
0728:  BTFSS  x70.7
072A:  BRA    075A
072C:  MOVLB  D
072E:  BTFSS  xF8.7
0730:  BRA    0736
0732:  MOVLB  E
0734:  BRA    075A
*
0E3E:  BTFSS  x70.7
0E40:  BRA    0E6A
0E42:  MOVLB  D
0E44:  BTFSS  xF8.7
0E46:  BRA    0E4C
0E48:  MOVLB  E
0E4A:  BRA    0E6A
....................    {
....................       ECANCON.ewin=TXRX5;
*
0736:  MOVLW  E0
0738:  ANDWF  F77,W
073A:  IORLW  17
073C:  MOVWF  F77
*
0E4C:  MOVLW  E0
0E4E:  ANDWF  F77,W
0E50:  IORLW  17
0E52:  MOVWF  F77
....................       stat.buffer=7;
*
073E:  MOVLW  07
0740:  MOVLB  0
0742:  MOVWF  x7E
*
0E54:  MOVLW  07
0E56:  MOVWF  53
.................... 
....................       //CAN_INT_RXB1IF=0;         //moved to end of function
.................... 
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl;
*
0744:  BCF    x7C.0
0746:  BTFSC  F74.6
0748:  BSF    x7C.0
*
0E58:  BCF    51.0
0E5A:  BTFSC  F74.6
0E5C:  BSF    51.0
....................       COMSTAT_MODE_1.rxnovfl = 0;
*
074A:  BCF    F74.6
*
0E5E:  BCF    F74.6
....................       stat.filthit=B5CONR.filhit;
*
074C:  MOVLB  E
074E:  MOVF   x70,W
0750:  ANDLW  1F
0752:  MOVLB  0
0754:  MOVWF  x7D
*
0E60:  MOVLB  E
0E62:  MOVF   x70,W
0E64:  ANDLW  1F
0E66:  MOVWF  52
.................... 
....................       //B5CONR.rxful=0;          //moved to end of function because this shouldn't be
....................                                  //cleared until after data has been retrieved from buffer
....................    }
....................   #endif
*
0756:  BRA    0762
0758:  MOVLB  E
*
0E68:  BRA    0E70
....................    else
....................    {
....................       #if CAN_DO_DEBUG
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n");
....................       #endif
....................       return (0);
*
075A:  MOVLW  00
075C:  MOVWF  01
075E:  BRA    0868
0760:  MOVLB  0
*
0E6A:  MOVLW  00
0E6C:  MOVWF  01
0E6E:  BRA    0F7A
0E70:  MOVLB  0
....................    }
.................... 
....................    len = RXBaDLC.dlc;
*
0762:  MOVF   F65,W
0764:  ANDLW  0F
0766:  MOVWF  x7B
*
0E72:  MOVF   F65,W
0E74:  ANDLW  0F
0E76:  MOVWF  50
....................    stat.rtr=RXBaDLC.rtr;
*
0768:  BCF    x7F.0
076A:  BTFSC  F65.6
076C:  BSF    x7F.0
*
0E78:  BCF    54.0
0E7A:  BTFSC  F65.6
0E7C:  BSF    54.0
.................... 
....................    stat.ext=TXRXBaSIDL.ext;
*
076E:  BCF    x7F.1
0770:  BTFSC  F62.3
0772:  BSF    x7F.1
*
0E7E:  BCF    54.1
0E80:  BTFSC  F62.3
0E82:  BSF    54.1
....................    id=can_get_id((unsigned int8*)TXRXBaID,stat.ext);
*
0774:  MOVLW  00
0776:  BTFSC  x7F.1
0778:  MOVLW  01
077A:  MOVWF  x8D
077C:  MOVLW  0F
077E:  MOVWF  x95
0780:  MOVLW  64
0782:  MOVWF  x94
0784:  MOVFF  8D,96
0788:  RCALL  00AE
078A:  MOVFF  03,72
078E:  MOVFF  02,71
0792:  MOVFF  01,70
0796:  MOVFF  00,6F
*
0E84:  MOVLW  00
0E86:  BTFSC  54.1
0E88:  MOVLW  01
0E8A:  MOVWF  x8D
0E8C:  MOVLW  0F
0E8E:  MOVWF  x95
0E90:  MOVLW  64
0E92:  MOVWF  x94
0E94:  MOVFF  8D,96
0E98:  CALL   00AE
0E9C:  MOVFF  03,47
0EA0:  MOVFF  02,46
0EA4:  MOVFF  01,45
0EA8:  MOVFF  00,44
.................... 
....................    ptr = &TXRXBaD0;
*
079A:  MOVLW  0F
079C:  MOVWF  x8C
079E:  MOVLW  66
07A0:  MOVWF  x8B
*
0EAC:  MOVLW  0F
0EAE:  MOVWF  x8C
0EB0:  MOVLW  66
0EB2:  MOVWF  x8B
....................    for ( i = 0; i < len; i++ )
*
07A2:  CLRF   x8A
07A4:  MOVF   x7B,W
07A6:  SUBWF  x8A,W
07A8:  BC    07D2
*
0EB4:  CLRF   x8A
0EB6:  MOVF   50,W
0EB8:  SUBWF  x8A,W
0EBA:  BC    0EE4
....................    {
....................       *data = *ptr;
*
07AA:  MOVFF  8B,FE9
07AE:  MOVFF  8C,FEA
07B2:  MOVFF  FEF,8F
07B6:  MOVFF  89,FEA
07BA:  MOVFF  88,FE9
07BE:  MOVFF  8F,FEF
*
0EBC:  MOVFF  8B,FE9
0EC0:  MOVFF  8C,FEA
0EC4:  MOVFF  FEF,8F
0EC8:  MOVFF  89,FEA
0ECC:  MOVFF  88,FE9
0ED0:  MOVFF  8F,FEF
....................       data++;
*
07C2:  INCF   x88,F
07C4:  BTFSC  FD8.2
07C6:  INCF   x89,F
*
0ED4:  INCF   x88,F
0ED6:  BTFSC  FD8.2
0ED8:  INCF   x89,F
....................       ptr++;
*
07C8:  INCF   x8B,F
07CA:  BTFSC  FD8.2
07CC:  INCF   x8C,F
07CE:  INCF   x8A,F
07D0:  BRA    07A4
*
0EDA:  INCF   x8B,F
0EDC:  BTFSC  FD8.2
0EDE:  INCF   x8C,F
0EE0:  INCF   x8A,F
0EE2:  BRA    0EB6
....................    }
.................... 
....................    switch(stat.buffer)     //switch statement to clear rxful flag and interrupt flag
*
07D2:  MOVF   x7E,W
07D4:  BZ    07F4
07D6:  XORLW  01
07D8:  BZ    0802
07DA:  XORLW  03
07DC:  BZ    080C
07DE:  XORLW  01
07E0:  BZ    0816
07E2:  XORLW  07
07E4:  BZ    0820
07E6:  XORLW  01
07E8:  BZ    082A
07EA:  XORLW  03
07EC:  BZ    0834
07EE:  XORLW  01
07F0:  BZ    083E
07F2:  BRA    0846
*
0EE4:  MOVF   53,W
0EE6:  BZ    0F06
0EE8:  XORLW  01
0EEA:  BZ    0F14
0EEC:  XORLW  03
0EEE:  BZ    0F1E
0EF0:  XORLW  01
0EF2:  BZ    0F28
0EF4:  XORLW  07
0EF6:  BZ    0F32
0EF8:  XORLW  01
0EFA:  BZ    0F3C
0EFC:  XORLW  03
0EFE:  BZ    0F46
0F00:  XORLW  01
0F02:  BZ    0F50
0F04:  BRA    0F58
....................    {
....................       case 0:
....................          RXB0CON.rxful=0;
*
07F4:  BCF    F60.7
*
0F06:  BCF    F60.7
....................         #if defined(CAN_FORCE_LEGACY_MODE)
....................          CAN_INT_RXB0IF=0;
....................         #else
....................          if(curfunmode)
*
07F6:  MOVF   1B,F
07F8:  BZ    07FE
*
0F08:  MOVF   1B,F
0F0A:  BZ    0F10
....................             CAN_INT_RXB1IF=0;
*
07FA:  BCF    FA4.1
07FC:  BRA    0800
*
0F0C:  BCF    FA4.1
0F0E:  BRA    0F12
....................          else
....................             CAN_INT_RXB0IF=0;
*
07FE:  BCF    FA4.0
*
0F10:  BCF    FA4.0
....................         #endif
....................          break;
*
0800:  BRA    0846
*
0F12:  BRA    0F58
....................       case 1:
....................          RXB1CON.rxful=0;
*
0802:  MOVLB  F
0804:  BCF    x50.7
*
0F14:  MOVLB  F
0F16:  BCF    x50.7
....................          CAN_INT_RXB1IF=0;
*
0806:  BCF    FA4.1
*
0F18:  BCF    FA4.1
....................          break;
*
0808:  MOVLB  0
080A:  BRA    0846
*
0F1A:  MOVLB  0
0F1C:  BRA    0F58
....................      #if !defined(CAN_FORCE_LEGACY_MODE)
....................       case 2:
....................          B0CONR.rxful=0;
*
080C:  MOVLB  E
080E:  BCF    x20.7
*
0F1E:  MOVLB  E
0F20:  BCF    x20.7
....................          CAN_INT_RXB1IF=0;
*
0810:  BCF    FA4.1
*
0F22:  BCF    FA4.1
....................          break;
*
0812:  MOVLB  0
0814:  BRA    0846
*
0F24:  MOVLB  0
0F26:  BRA    0F58
....................       case 3:
....................          B1CONR.rxful=0;
*
0816:  MOVLB  E
0818:  BCF    x30.7
*
0F28:  MOVLB  E
0F2A:  BCF    x30.7
....................          CAN_INT_RXB1IF=0;
*
081A:  BCF    FA4.1
*
0F2C:  BCF    FA4.1
....................          break;
*
081C:  MOVLB  0
081E:  BRA    0846
*
0F2E:  MOVLB  0
0F30:  BRA    0F58
....................       case 4:
....................          B2CONR.rxful=0;
*
0820:  MOVLB  E
0822:  BCF    x40.7
*
0F32:  MOVLB  E
0F34:  BCF    x40.7
....................          CAN_INT_RXB1IF=0;
*
0824:  BCF    FA4.1
*
0F36:  BCF    FA4.1
....................          break;
*
0826:  MOVLB  0
0828:  BRA    0846
*
0F38:  MOVLB  0
0F3A:  BRA    0F58
....................       case 5:
....................          B3CONR.rxful=0;
*
082A:  MOVLB  E
082C:  BCF    x50.7
*
0F3C:  MOVLB  E
0F3E:  BCF    x50.7
....................          CAN_INT_RXB1IF=0;
*
082E:  BCF    FA4.1
*
0F40:  BCF    FA4.1
....................          break;
*
0830:  MOVLB  0
0832:  BRA    0846
*
0F42:  MOVLB  0
0F44:  BRA    0F58
....................       case 6:
....................          B4CONR.rxful=0;
*
0834:  MOVLB  E
0836:  BCF    x60.7
*
0F46:  MOVLB  E
0F48:  BCF    x60.7
....................          CAN_INT_RXB1IF=0;
*
0838:  BCF    FA4.1
*
0F4A:  BCF    FA4.1
....................          break;
*
083A:  MOVLB  0
083C:  BRA    0846
*
0F4C:  MOVLB  0
0F4E:  BRA    0F58
....................       case 7:
....................          B5CONR.rxful=0;
*
083E:  MOVLB  E
0840:  BCF    x70.7
*
0F50:  MOVLB  E
0F52:  BCF    x70.7
....................          CAN_INT_RXB1IF=0;
*
0842:  BCF    FA4.1
*
0F54:  BCF    FA4.1
....................          break;
*
0844:  MOVLB  0
*
0F56:  MOVLB  0
....................      #endif
....................    }
.................... 
....................    stat.inv=CAN_INT_IRXIF;
*
0846:  BCF    x7F.2
0848:  BTFSC  FA4.7
084A:  BSF    x7F.2
*
0F58:  BCF    54.2
0F5A:  BTFSC  FA4.7
0F5C:  BSF    54.2
....................    CAN_INT_IRXIF = 0;
*
084C:  BCF    FA4.7
*
0F5E:  BCF    FA4.7
.................... 
....................    // return to default addressing
....................   #if defined(CAN_FORCE_LEGACY_MODE)
....................    CANCON.win=CAN_WIN_RX0;
....................   #else
....................    if(curfunmode==CAN_FUN_OP_LEGACY)
*
084E:  MOVF   1B,F
0850:  BNZ   085A
*
0F60:  MOVF   1B,F
0F62:  BNZ   0F6C
....................       CANCON.win=CAN_WIN_RX0;
*
0852:  MOVLW  F1
0854:  ANDWF  F6F,W
0856:  MOVWF  F6F
0858:  BRA    0862
*
0F64:  MOVLW  F1
0F66:  ANDWF  F6F,W
0F68:  MOVWF  F6F
0F6A:  BRA    0F74
....................    else
....................       ECANCON.ewin=RX0;
*
085A:  MOVLW  E0
085C:  ANDWF  F77,W
085E:  IORLW  10
0860:  MOVWF  F77
*
0F6C:  MOVLW  E0
0F6E:  ANDWF  F77,W
0F70:  IORLW  10
0F72:  MOVWF  F77
....................   #endif
.................... 
....................    #if CAN_DO_DEBUG
....................       can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl);
....................       can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv);
....................       if ((len)&&(!stat.rtr))
....................       {
....................          data-=len;
....................          can_debug("\r\n    DATA = ");
....................          for (i=0;i<len;i++)
....................          {
....................             can_debug("%X ",*data);
....................             data++;
....................          }
....................       }
....................       can_debug("\r\n");
....................    #endif
.................... 
....................    return(1);
*
0862:  MOVLW  01
0864:  MOVWF  01
0866:  MOVLB  E
*
0F74:  MOVLW  01
0F76:  MOVWF  01
0F78:  MOVLB  E
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_enable_b_transfer: mode 1 & 2
.................... //
.................... // Sets one of the 6 programmable buffers to be a transfer buffer.  This uses
.................... // a simple bitwise operation so that more than one buffer can be set at a
.................... // time.
.................... //
.................... // The register that contains the TX/RX information is BSEL0 and the control
.................... //   bits take up the 6 most significant bits.  Therefore a value of 0x04 would
.................... //   set B0 as a transmit buffer while a value of 0xFC would set all of the
.................... // programmable buffers to transmit buffers.
.................... //
.................... //   Parameters:
.................... //      b - the buffer which is to become a transfer buffer
.................... //       enumerated as - B0,B1,B2,B3,B4,B5
.................... //
.................... // More information can be found on the programmable buffers in the PIC18F4580
.................... //   datasheet, section 23.5.3
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void can_enable_b_transfer(PROG_BUFFER b)
.................... {
....................    unsigned int8 temp;
.................... 
....................    temp=BSEL0;
....................    temp|=b;
.................... 
....................    BSEL0=temp;
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_enable_b_receiver: mode 1 & 2
.................... //
.................... // Sets one of the 6 programmable buffers to be a receiver buffer.  This uses
.................... // a simple bitwise operation so that more than one buffer can be set at a
.................... // time.
.................... //
.................... // The register that contains the TX/RX information is BSEL0 and the control
.................... //   bits take up the 6 most significant bits.  Therefore a value of 0x04 would
.................... //   set B0 as a receive buffer while a value of 0xFC would set all of the
.................... // programmable buffers to receive buffers.
.................... //
.................... // Parameters:
.................... //    b - the buffer which is to become a receiver buffer
.................... //       enumerated as - B0,B1,B2,B3,B4,B5
.................... //
.................... // returns:
.................... //      void
.................... //
.................... // More information can be found on the programmable buffers in the PIC18F4580
.................... // datasheet, section 23.5.3
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void can_enable_b_receiver(PROG_BUFFER b)
.................... {
....................    unsigned int8 temp;
.................... 
....................    temp=BSEL0;
....................    temp&=~b;
.................... 
....................    BSEL0=temp;
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_enable_rtr: mode 1 & 2
.................... //
.................... // Prepares one of the programmable registers to be used as an Auto-rtr buffer
.................... //   This function allows for multiple rtr enables.
.................... //
.................... // Parameters:
.................... //      b - the programmable buffer to be set to Auto-rtr mode
.................... //       enumerated as - B0,B1,B2,B3,B4,B5
.................... //
.................... //      b=0x04 - B0 rtr enable
.................... //      b=0x08 - B1 rtr enable
.................... //      b=0x10 - B2 rtr enable
.................... //      b=0x20 - B3 rtr enable
.................... //    b=0x40 - B4 rtr enable
.................... //      b=0x80 -   B5 rtr enable
.................... //
.................... //      any logical and (&) combination of the above will also work
.................... //
.................... //      b = 0x04 & 0x80 = 0x84 - B0 and B5 rtr enable
.................... //
.................... // returns:
.................... //     void
.................... //
.................... // More information can be found on Auto-rtr in the PIC18F4580 datasheet,
.................... //   section 23.5.4
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void can_enable_rtr(PROG_BUFFER b)
.................... {
.................... 
....................    can_enable_b_transfer ( b );
.................... 
....................    if(bit_test(b,2))
....................       B0CONTA|=0x04;
....................    if(bit_test(b,3))
....................       B1CONTA|=0x04;
....................    if(bit_test(b,4))
....................       B2CONTA|=0x04;
....................    if(bit_test(b,5))
....................       B3CONTA|=0x04;
....................    if(bit_test(b,6))
....................       B4CONTA|=0x04;
....................    if(bit_test(b,7))
....................       B5CONTA|=0x04;
.................... 
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_disable_rtr: mode 1 & 2
.................... //
.................... // disables certain programmable registers from being used as Auto-rtr buffers
.................... //   This function allows for multiple rtr disables.
.................... //
.................... // Parameters:
.................... //      b - the programmable buffer to be set to Auto-rtr mode
.................... //       enumerated as B0,B1,B2,B3,B4,B5
.................... //
.................... //      b=0x04 - B0 rtr disable
.................... //      b=0x08 - B1 rtr disable
.................... //      b=0x10 - B2 rtr disable
.................... //      b=0x20 - B3 rtr disable
.................... //    b=0x40 - B4 rtr disable
.................... //      b=0x80 -   B5 rtr disable
.................... //
.................... //      any logical or (|) combination of the above will also work
.................... //
.................... //      b = 0x04 | 0x80 = 0x84 - B0 and B5 rtr disable
.................... //
.................... // returns:
.................... //     void
.................... //
.................... // More information can be found on Auto-rtr in the PIC18F4580 datasheet,
.................... //   section 23.5.4
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void can_disable_rtr(PROG_BUFFER b)
.................... {
....................    if(bit_test(b,2))
....................       B0CONTA&=0xfb;
....................    if(bit_test(b,3))
....................       B1CONTA&=0xfb;
....................    if(bit_test(b,4))
....................       B2CONTA&=0xfb;
....................    if(bit_test(b,5))
....................       B3CONTA&=0xfb;
....................    if(bit_test(b,6))
....................       B4CONTA&=0xfb;
....................    if(bit_test(b,7))
....................       B5CONTA&=0xfb;
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_load_rtr: mode 1 & 2
.................... //
.................... //   Loads a SINGLE b buffer with data to be sent on the occurrence of an rtr.
.................... //
.................... // Parameters:
.................... //
.................... //      b - The programmable buffer to be filled
.................... //       enumerated as - B0,B1,B2,B3,B4,B5
.................... //      data - the address of the first data byte
.................... //      len - the number of data bytes to be copied
.................... //
.................... // Returns:
.................... //      void
.................... //
.................... //   Note, the programmer must set the appropriate rtr registers in order for the
.................... //         rtr function to work.  This function does not set any of those
.................... //         registers.  For example, to enable B0 as an Auto-rtr buffer, the
.................... //         functions:
.................... //
.................... //         can_enable_b_transfer(B0);
.................... //         can_enable_rtr(B0);
.................... //         function to link acceptance filter to B0
.................... //
.................... //         need to be called.
.................... //
.................... //   can_load_rtr does no damage to the current mode of the ECAN
.................... //
.................... // More information on the Auto-rtr can be found in the PIC18F4580 datasheet
.................... // section 23.5.4
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... void can_load_rtr (PROG_BUFFER b, unsigned int8 *data, unsigned int8 len)
.................... {
.................... 
....................    unsigned int8 *ptr;
.................... 
....................    //do no damage to the current mode;
....................    curmode = CANSTAT.opmode;
.................... 
....................    can_set_mode(CAN_OP_CONFIG);
.................... 
....................    if(bit_test(b,2))
....................    {
....................       ptr=&B0D0;
....................       B0DLCT=len;
....................    }
....................    else if (bit_test(b,3))
....................    {
....................       ptr=&B1D0;
....................       B1DLCT=len;
....................    }
....................    else if (bit_test(b,4))
....................    {
....................       ptr=&B2D0;
....................       B2DLCT=len;
....................    }
....................    else if (bit_test(b,5))
....................    {
....................       ptr=&B3D0;
....................       B3DLCT=len;
....................    }
....................    else if (bit_test(b,6))
....................    {
....................       ptr=&B4D0;
....................       B4DLCT=len;
....................    }
....................    else if (bit_test(b,7))
....................    {
....................       ptr=&B5D0;
....................       B5DLCT=len;
....................    }
....................    else
....................       return;
.................... 
....................    for(;len>0;len--) {
....................       *ptr=*data;
....................       ptr++;
....................       data++;
....................    }
.................... 
....................    can_set_mode(curmode);
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_enable_filter: mode 1 , 2 & 3
.................... //
.................... //   Enables a given acceptance filter
.................... //
.................... // Parameters:
.................... //      filter - the filter that is to be enabled
.................... //         enumerated as - RXF0EN-RXF15EN
.................... //
.................... // Returns:
.................... //    void
.................... //
.................... // More information can be found on Acceptance Filters in the PIC18F4580
.................... // datasheet, Section 23.8
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... void can_enable_filter(unsigned long filter)
.................... {
....................    unsigned long *ptr;
.................... 
....................    curmode=CANSTAT.opmode;
.................... 
....................    can_set_mode(CAN_OP_CONFIG);
.................... 
....................    ptr = &RXFCON0;
.................... 
....................    *ptr|=filter;
.................... 
....................    can_set_mode(curmode);
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_disable_filter: mode 0 , 1 & 2
.................... //
.................... // Disables a given acceptance filter
.................... //
.................... // Parameters:
.................... //      filter - the filter that is to be disabled
.................... //        enumerated as - RXF0EN-RXF15EN
.................... //
.................... // Returns:
.................... //      void;
.................... //
.................... // More information can be found on Acceptance Filters in the PIC18F4580
.................... // datasheet, Section 23.8
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... void can_disable_filter(unsigned long filter)
.................... {
....................    unsigned long *ptr;
.................... 
....................    curmode=CANSTAT.opmode;
.................... 
....................    can_set_mode(CAN_OP_CONFIG);
.................... 
....................    ptr = &RXFCON0;
.................... 
....................    *ptr&=~filter;
.................... 
....................    can_set_mode(curmode);
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_associate_filter_to_buffer: mode 1 & 2
.................... //
.................... // Associates a given buffer with a given filter register
.................... //
.................... // Parameters:
.................... //      buffer - the buffer that is to be associated with the filter
.................... //        enumerated as
.................... //               ARXB0-ARXB1 - Dedicated receive buffers RX0-RX1
.................... //               AB0-AB5 - Programmable receive buffers B0-B5
.................... //
.................... //      filter - the filter that is to be associated with the buffer
.................... //         enumerated as
.................... //               F0BP-F15BP - Filters 0 - 15
.................... //
.................... //
.................... // Returns:
.................... //      void
.................... //
.................... //   More information can be found on Acceptance Filters in the PIC18F4580
.................... // datasheet, Section 23.8
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... void can_associate_filter_to_buffer(CAN_FILTER_ASSOCIATION_BUFFERS buffer, CAN_FILTER_ASSOCIATION filter)
.................... {
....................    unsigned int8 *ptr;
.................... 
....................    curmode=CANSTAT.opmode;
.................... 
....................    can_set_mode(CAN_OP_CONFIG);
.................... 
....................    ptr = &RXFBCON0 + (filter >> 1);
.................... 
....................    if((filter & 0x01) == 1)
....................    {
....................       *ptr&=0x0f;
....................       *ptr|=buffer<<4;
....................    }
....................    else
....................    {
....................       *ptr&=0xf0;
....................       *ptr|=buffer;
....................    }
.................... 
....................    can_set_mode(curmode);
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_associate_filter_to_mask
.................... //
.................... //   Associates a given filter to a given mask
.................... //
.................... //   Parameters:
.................... //      mask - the mask that is to be associated with the filter
.................... //         enumerated as
.................... //            ACCEPTANCE_MASK_0
.................... //            ACCEPTANCE_MASK_1
.................... //            FILTER_15
.................... //            NO_MASK
.................... //
.................... //      filter - the filter that is to be associated with the mask
.................... //         enumerated as
.................... //               F0BP-F15BP - Filters 0 - 15
.................... //
.................... //
.................... //   Returns:
.................... //      void
.................... //
.................... // More information can be found on Acceptance Filters in the PIC18F4580
.................... // datasheet, Section 23.8
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... void can_associate_filter_to_mask(CAN_MASK_FILTER_ASSOCIATE mask, CAN_FILTER_ASSOCIATION filter)
.................... {
....................    unsigned int8 *ptr;
.................... 
....................    curmode = CANSTAT.opmode;
.................... 
....................    can_set_mode(CAN_OP_CONFIG);
.................... 
....................    ptr = &MSEL0 + (filter >> 2);
.................... 
....................    if((filter & 0x03)==0)
....................    {
....................       *ptr&=0xfc;
....................       *ptr|=mask;
....................    }
....................    else if((filter & 0x03)==1)
....................    {
....................       *ptr&=0xf3;
....................       *ptr|=mask<<2;
....................    }
....................    else if((filter & 0x03)==2)
....................    {
....................       *ptr&=0xcf;
....................       *ptr|=mask<<4;
....................    }
....................    else if((filter & 0x03)==3)
....................    {
....................       *ptr&=0x3f;
....................       *ptr|=mask<<6;
....................    }
.................... 
....................    can_set_mode(curmode);
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_FIFO_getd
.................... //
.................... // Retrieves data in Mode 2
.................... //
.................... // Parameters:
.................... //      id - The ID of the sender
.................... //      data - Address of the array to store the data in
.................... //      len - number of data bytes to read
.................... //      stat - status structure to return information about the receive register
.................... //
.................... // Returns:
.................... //      int1 - TRUE if there was data in the buffer, FALSE if there wasn't
.................... //
.................... // More information can be found on the FIFO mode in the PIC18F4580 datasheet
.................... // section 23.7.3
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... int1 can_fifo_getd(unsigned int32 &id, unsigned int8 *data, unsigned int8 &len, struct rx_stat &stat )
.................... {
.................... 
....................    unsigned int8 i;
....................    unsigned int8 *ptr;
.................... 
....................    if(!COMSTAT_MODE_2.fifoempty)          // if there is no data in the buffer
....................       return(0);                          // return false;
.................... 
....................    ECANCON.ewin=CANCON_MODE_2.fp | 0x10;
....................    stat.buffer=CANCON_MODE_2.fp;
.................... 
....................    //CAN_INT_RXB1IF=0;                    // moved to end of function
.................... 
....................    stat.err_ovfl=COMSTAT_MODE_2.rxnovfl;
....................    COMSTAT_MODE_2.rxnovfl = 0;
....................    stat.filthit=RXB0CON_MODE_2.filthit;
.................... 
....................    len = RXBaDLC.dlc;
....................    stat.rtr=RXBaDLC.rtr;
.................... 
....................    stat.ext=TXRXBaSIDL.ext;
....................    id=can_get_id((unsigned int8*)TXRXBaID,stat.ext);
.................... 
....................    ptr = &TXRXBaD0;
....................    for ( i = 0; i < len; i++ ) {
....................        *data = *ptr;
....................        data++;
....................        ptr++;
....................    }
.................... 
....................    RXB0CON_MODE_2.rxful=0;
.................... 
....................    CAN_INT_RXB1IF=0;
.................... 
....................    // return to default addressing
....................    ECANCON.ewin=RX0;
.................... 
....................    stat.inv=CAN_INT_IRXIF;
....................    CAN_INT_IRXIF = 0;
.................... 
....................    return(1);
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //
.................... // can_t0_putd - can_t2_putd
.................... // can_b0_putd - can_b5_putd
.................... //
.................... // places data to be transferred in a specified buffer
.................... //
.................... // Parameters:
.................... //      id - id that will be sent with the data
.................... //    data - pointer to the data
.................... //      len - number of data bytes (0-8)
.................... //      pri - priority (0-3)
.................... //      ext - extended or not
.................... //    rtr - request remote transfer
.................... //
.................... // Returns:
.................... //      TRUE if data is successfully loaded into the buffer
.................... //      FALSE if data can not be loaded into the buffer
.................... //
.................... //   Notes
.................... //      - make sure that the desired buffer is set to be a transfer buffer
.................... //        using the can_enable_b_transfer ( ) function
.................... //
.................... // More information can be found on using the transfer buffers in the PICF4580
.................... //   datasheet section 23.6
.................... //
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // transfer buffer 0
.................... int1 can_t0_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 pri, int1 ext, int1 rtr)
.................... {
....................    unsigned int8 *ptr;
.................... 
....................    if(TXB0CON.txreq)
....................       return ( FALSE );
.................... 
....................    can_set_id((unsigned int8*)TXB0ID, id, ext );
.................... 
....................    TXB0DLC.dlc = len;
.................... 
....................    TXB0CON.txpri = pri;
.................... 
....................    TXB0DLC.rtr = rtr;
.................... 
....................    ptr = &TXB0D0;
.................... 
....................    for(;len>0;len--)
....................    {
....................       *ptr = *data;
....................       ptr++;
....................       data++;
....................    }
.................... 
....................    TXB0CON.txreq = 1;
.................... 
....................    return ( TRUE );
.................... }
.................... 
.................... // transfer buffer 1
.................... int1 can_t1_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 pri, int1 ext, int1 rtr)
.................... {
....................    unsigned int8 *ptr;
.................... 
....................    if(TXB1CON.txreq)
....................       return ( FALSE );
.................... 
....................    can_set_id((unsigned int8*)TXB1ID, id, ext );
.................... 
....................    TXB1DLC.dlc = len;
.................... 
....................    TXB1CON.txpri = pri;
.................... 
....................    TXB1DLC.rtr = rtr;
.................... 
....................    ptr = &TXB1D0;
.................... 
....................    for(;len>0;len--)
....................    {
....................       *ptr = *data;
....................       ptr++;
....................       data++;
....................    }
.................... 
....................    TXB1CON.txreq = 1;
.................... 
....................    return ( TRUE );
.................... }
.................... 
.................... // transfer buffer 2
.................... int1 can_t2_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 pri, int1 ext, int1 rtr)
.................... {
....................    unsigned int8 *ptr;
.................... 
....................    if(TXB2CON.txreq)
....................       return ( FALSE );
.................... 
....................    can_set_id((unsigned int8*)TXB2ID, id, ext );
.................... 
....................    TXB2DLC.dlc = len;
.................... 
....................    TXB2CON.txpri = pri;
.................... 
....................    TXB2DLC.rtr = rtr;
.................... 
....................    ptr = &TXB2D0;
.................... 
....................    for(;len>0;len--)
....................    {
....................       *ptr = *data;
....................       ptr++;
....................       data++;
....................    }
.................... 
....................    TXB2CON.txreq = 1;
.................... 
....................    return ( TRUE );
.................... }
.................... 
.................... // programmable buffer 0
.................... int1 can_b0_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 pri, int1 ext, int1 rtr)
.................... {
....................    unsigned int8 *txd0;
.................... 
....................    txd0=&TXRXBaD0;
.................... 
....................    if (B0CONT.txreq || !BSEL0.b0txen)
....................       return ( FALSE );
.................... 
....................    ECANCON.ewin=TXRX0;
.................... 
....................     //set priority.
....................    TXBaCON.txpri=pri;
.................... 
....................    //set tx mask
....................    can_set_id((unsigned int8*)TXRXBaID, id, ext);
.................... 
....................    //set tx data count
....................    TXBaDLC=len;
....................    TXBaDLC.rtr=rtr;
.................... 
....................     for (;len>0;len--)
....................     {
....................       *txd0=*data;
....................       txd0++;
....................       data++;
....................     }
.................... 
....................    //enable transmission
....................    TXBaCON.txreq=1;
.................... 
....................    // return to default addressing
....................    ECANCON.ewin=RX0;
.................... 
....................    return ( TRUE );
.................... 
.................... }
.................... 
.................... // programmable buffer 1
.................... int1 can_b1_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 pri, int1 ext, int1 rtr)
.................... {
....................    unsigned int8 *txd0;
.................... 
....................    txd0=&TXRXBaD0;
.................... 
....................    if (B1CONT.txreq || !BSEL0.b1txen)
....................       return ( FALSE );
.................... 
....................    ECANCON.ewin=TXRX1;
.................... 
....................     //set priority.
....................    TXBaCON.txpri=pri;
.................... 
....................    //set tx mask
....................    can_set_id((unsigned int8*)TXRXBaID, id, ext);
.................... 
....................    //set tx data count
....................    TXBaDLC=len;
....................    TXBaDLC.rtr=rtr;
.................... 
....................     for (;len>0;len--)
....................     {
....................       *txd0=*data;
....................       txd0++;
....................       data++;
....................     }
.................... 
....................    //enable transmission
....................    TXBaCON.txreq=1;
.................... 
....................    // return to default addressing
....................    ECANCON.ewin=RX0;
.................... 
....................    return ( TRUE );
.................... }
.................... 
.................... // programmable buffer 2
.................... int1 can_b2_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 pri, int1 ext, int1 rtr)
.................... {
....................    unsigned int8 *txd0;
.................... 
....................    txd0=&TXRXBaD0;
.................... 
....................    if (B2CONT.txreq || !BSEL0.b2txen)
....................       return ( FALSE );
.................... 
....................    ECANCON.ewin=TXRX2;
.................... 
....................     //set priority.
....................    TXBaCON.txpri=pri;
.................... 
....................    //set tx mask
....................    can_set_id((unsigned int8*)TXRXBaID, id, ext);
.................... 
....................    //set tx data count
....................    TXBaDLC=len;
....................    TXBaDLC.rtr=rtr;
.................... 
....................     for (;len>0;len--)
....................     {
....................       *txd0=*data;
....................       txd0++;
....................       data++;
....................     }
.................... 
....................    //enable transmission
....................    TXBaCON.txreq=1;
.................... 
....................    // return to default addressing
....................    ECANCON.ewin=RX0;
.................... 
....................    return ( TRUE );
.................... }
.................... 
.................... // programmable buffer 3
.................... int1 can_b3_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 pri, int1 ext, int1 rtr)
.................... {
....................    unsigned int8 *txd0;
.................... 
....................    txd0=&TXRXBaD0;
.................... 
....................    if (B3CONT.txreq || !BSEL0.b3txen)
....................       return ( FALSE );
.................... 
....................    ECANCON.ewin=TXRX3;
.................... 
....................     //set priority.
....................    TXBaCON.txpri=pri;
.................... 
....................    //set tx mask
....................    can_set_id((unsigned int8*)TXRXBaID, id, ext);
.................... 
....................    //set tx data count
....................    TXBaDLC=len;
....................    TXBaDLC.rtr=rtr;
.................... 
....................     for (;len>0;len--)
....................     {
....................       *txd0=*data;
....................       txd0++;
....................       data++;
....................     }
.................... 
....................    //enable transmission
....................    TXBaCON.txreq=1;
.................... 
....................    // return to default addressing
....................    ECANCON.ewin=RX0;
.................... 
....................    return ( TRUE );
.................... 
.................... }
.................... 
.................... // programmable buffer 4
.................... int1 can_b4_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 pri, int1 ext, int1 rtr)
.................... {
....................    unsigned int8 *txd0;
.................... 
....................    txd0=&TXRXBaD0;
.................... 
....................    if (B4CONT.txreq || !BSEL0.b4txen)
....................       return ( FALSE );
.................... 
....................    ECANCON.ewin=TXRX4;
.................... 
....................     //set priority.
....................    TXBaCON.txpri=pri;
.................... 
....................    //set tx mask
....................    can_set_id((unsigned int8*)TXRXBaID, id, ext);
.................... 
....................    //set tx data count
....................    TXBaDLC=len;
....................    TXBaDLC.rtr=rtr;
.................... 
....................     for (;len>0;len--)
....................     {
....................       *txd0=*data;
....................       txd0++;
....................       data++;
....................     }
.................... 
....................    //enable transmission
....................    TXBaCON.txreq=1;
.................... 
....................    // return to default addressing
....................    ECANCON.ewin=RX0;
.................... 
....................    return ( TRUE );
.................... }
.................... 
.................... // programmable buffer 5
.................... int1 can_b5_putd(unsigned int32 id, unsigned int8 *data, unsigned int8 len, unsigned int8 pri, int1 ext, int1 rtr)
.................... {
....................    unsigned int8 *txd0;
.................... 
....................    txd0=&TXRXBaD0;
.................... 
....................    if (B5CONT.txreq || !BSEL0.b5txen)
....................       return ( FALSE );
.................... 
....................    ECANCON.ewin=TXRX5;
.................... 
....................     //set priority.
....................    TXBaCON.txpri=pri;
.................... 
....................    //set tx mask
....................    can_set_id((unsigned int8*)TXRXBaID, id, ext);
.................... 
....................    //set tx data count
....................    TXBaDLC=len;
....................    TXBaDLC.rtr=rtr;
.................... 
....................    for (;len>0;len--)
....................    {
....................      *txd0=*data;
....................      txd0++;
....................      data++;
....................    }
.................... 
....................    txd0=&B5D0;
.................... 
....................    //enable transmission
....................    TXBaCON.txreq=1;
.................... 
....................    // return to default addressing
....................    ECANCON.ewin=RX0;
.................... 
....................    return ( TRUE );
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #define CAN_ID_PEDAL_BOARD  0x01 // board CAN ID
.................... #define CAN_ID_PEDAL_CALIB  0x02 // board CAN ID
.................... #define CAN_ID_CONDICION  0x03    // ID que debe recibirse antes de enviar por can la ID 2
.................... #define CAN_PRIORITY 0x11 // max priority
.................... #define CAN_BUFFER_LENGTH 8 // set buffer to be sent by CAN
.................... 
.................... #define VENTANA 5   //TamaÃ±o de la ventana de la media movil
.................... #define MAX_IGNORE_VALUE 250
.................... 
.................... const int16 TIME_INTERVAL_1MS = 65459;
.................... unsigned int8 avgA1 = 0;
.................... unsigned int8 avgA2 = 0;
.................... unsigned int8 avgA3 = 0;
.................... unsigned int8 avgBrk = 0;
.................... unsigned int8 avgSens = 0;
.................... int1 received_id3 = FALSE;  // Variable para saber si se recibió un mensaje de ID 3
.................... 
.................... // Each 1ms interrupt
.................... /*#int_RTCC
.................... void RTCC_isr(void) {
....................     counter++;
....................     
....................     if (counter >= 5) {
....................         // each 5 ms
....................         counter    = 0;
....................         readAdc    = 1;
....................     }
.................... }*/
.................... 
.................... int8 readChanel(int ch) {
....................     set_adc_channel(ch);   // enable adc
....................     delay_us(20);          // wait time
....................     return read_adc();    // read ADC value (0-255)
.................... }
.................... 
.................... int8 factorConversion(unsigned int16 MAX, unsigned int16 min, unsigned int16 data){
....................    if (data<=min) {return 0;}
....................    else if (data>=MAX) {return 255;}
....................    else {return ((data - min)*255)/(MAX - min);}
.................... }
....................    
.................... unsigned int8 media_movil (unsigned int16 data){
....................  
....................    unsigned int8 filtered_data=0, i;
....................    unsigned int16 BRK_valores [VENTANA] = {0};
....................    for(i=VENTANA-1;i>0;i--){
....................       BRK_valores[i]=BRK_valores[i-1];      //Empuja hacia la derecha en el array
....................       filtered_data += BRK_valores[i];      //Suma el anterior dato para la media
....................    }
....................    BRK_valores [0] = data;                  //Empuja el nuevo dato en el array
....................    filtered_data+=BRK_valores [0];            //Suma el nuevo dato para la media
....................    filtered_data/=VENTANA;
....................    
....................    return filtered_data;
.................... }
.................... 
.................... // Función de interrupción para recibir mensajes CAN
.................... #int_canrx0
.................... void canrx0_int(void) {
....................    
....................     disable_interrupts(GLOBAL);
*
0578:  BCF    FF2.6
057A:  BCF    FF2.7
057C:  BTFSC  FF2.7
057E:  BRA    057A
....................     disable_interrupts(int_canrx0);
0580:  BCF    FA3.0
....................     volatile INT32 id;
....................     volatile UNSIGNED int8 buffer[8]={0};
0582:  CLRF   x73
0584:  CLRF   x74
0586:  CLRF   x75
0588:  CLRF   x76
058A:  CLRF   x77
058C:  CLRF   x78
058E:  CLRF   x79
0590:  CLRF   x7A
....................     int8 len=8;
....................     struct rx_stat rxstat;
0592:  MOVLW  08
0594:  MOVWF  x7B
....................     
....................     if (can_getd(id, buffer, len, rxstat)) {
0596:  CLRF   x89
0598:  MOVLW  73
059A:  MOVWF  x88
*
0868:  MOVF   01,F
086A:  BZ    0884
....................         if (id == 0x3) { // Si el mensaje recibido es de ID 3
086C:  MOVLB  0
086E:  MOVF   x6F,W
0870:  SUBLW  03
0872:  BNZ   0882
0874:  MOVF   x70,F
0876:  BNZ   0882
0878:  MOVF   x71,F
087A:  BNZ   0882
087C:  MOVF   x72,F
087E:  BNZ   0882
....................             received_id3 = 1;
0880:  BSF    21.0
0882:  MOVLB  E
....................         }
....................     }
....................     received_id3 = 1;
0884:  BSF    21.0
....................     if (received_id3==1) {
0886:  BTFSS  21.0
0888:  BRA    08CA
....................         unsigned int8 bufferCalib[8] = {0};
088A:  MOVLB  0
088C:  CLRF   x80
088E:  CLRF   x81
0890:  CLRF   x82
0892:  CLRF   x83
0894:  CLRF   x84
0896:  CLRF   x85
0898:  CLRF   x86
089A:  CLRF   x87
....................         bufferCalib[0] = 1;
089C:  MOVLW  01
089E:  MOVWF  x80
....................         bufferCalib[1] = 1;
08A0:  MOVWF  x81
....................         bufferCalib[2] = 1;
08A2:  MOVWF  x82
....................         bufferCalib[3] = 1;
08A4:  MOVWF  x83
....................         bufferCalib[4] = 1;
08A6:  MOVWF  x84
....................         can_putd(CAN_ID_PEDAL_CALIB, bufferCalib, CAN_BUFFER_LENGTH, CAN_PRIORITY, false, false);
08A8:  CLRF   x8B
08AA:  CLRF   x8A
08AC:  CLRF   x89
08AE:  MOVLW  02
08B0:  MOVWF  x88
08B2:  CLRF   x8D
08B4:  MOVLW  80
08B6:  MOVWF  x8C
08B8:  MOVLW  08
08BA:  MOVWF  x8E
08BC:  MOVLW  11
08BE:  MOVWF  x8F
08C0:  CLRF   x90
08C2:  CLRF   x91
08C4:  RCALL  03B6
....................         received_id3 = 0; // Reseteamos la variable después de enviar el mensaje
08C6:  BCF    21.0
08C8:  MOVLB  E
....................     }
....................     enable_interrupts(GLOBAL);
08CA:  MOVLW  C0
08CC:  IORWF  FF2,F
....................     enable_interrupts(int_canrx0);
08CE:  BSF    FA3.0
....................     
08D0:  BCF    FA4.0
08D2:  MOVLB  0
08D4:  GOTO   0060
.................... }
.................... 
.................... 
.................... 
.................... 
....................    
.................... 
.................... void main()
*
0BCC:  CLRF   FF8
0BCE:  BCF    FD0.7
0BD0:  BSF    07.7
0BD2:  CLRF   1C
0BD4:  CLRF   1D
0BD6:  CLRF   1E
0BD8:  CLRF   1F
0BDA:  CLRF   20
0BDC:  BCF    21.0
0BDE:  MOVF   FC1,W
0BE0:  ANDLW  C0
0BE2:  IORLW  0F
0BE4:  MOVWF  FC1
*
0BF6:  CLRF   2B
0BF8:  CLRF   2A
0BFA:  CLRF   2D
0BFC:  CLRF   2C
0BFE:  CLRF   2F
0C00:  CLRF   2E
0C02:  CLRF   31
0C04:  CLRF   30
0C06:  CLRF   33
0C08:  CLRF   32
0C0A:  CLRF   35
0C0C:  CLRF   34
0C0E:  CLRF   37
0C10:  CLRF   36
0C12:  CLRF   39
0C14:  CLRF   38
0C16:  CLRF   3B
0C18:  CLRF   3A
0C1A:  CLRF   3D
0C1C:  CLRF   3C
0C1E:  CLRF   3E
0C20:  CLRF   3F
0C22:  CLRF   40
0C24:  CLRF   41
0C26:  CLRF   42
0C28:  CLRF   43
.................... {
....................     unsigned int8 buffer[8] = {0};
*
0BE6:  CLRF   22
0BE8:  CLRF   23
0BEA:  CLRF   24
0BEC:  CLRF   25
0BEE:  CLRF   26
0BF0:  CLRF   27
0BF2:  CLRF   28
0BF4:  CLRF   29
....................     unsigned int16 prevA1 = 0, prevA2 = 0, prevA3 = 0, prevBrk = 0, prevSens = 0;
....................     unsigned int16 A1 = 0, A2 = 0, A3 = 0, Brk = 0, Sens = 0;
....................     unsigned int8 avgA1Calib = 0, avgA2Calib = 0, avgA3Calib = 0,avgBrkCalib = 0, avgSensCalib = 0, BRK_filtered = 0;
....................     
.................... 
....................     set_tris_a(0b00111111); // set AN0 to AN4 as input (APP1,APP2,BRK,APP3 and Simu)
*
0C2A:  MOVLW  3F
0C2C:  MOVWF  F92
....................     set_tris_b(0b00001000); // set CANRX as input and CANTX as output
0C2E:  MOVLW  08
0C30:  MOVWF  F93
....................     set_tris_c(0b10000000); // set RC5 as output and RC7 as input
0C32:  MOVLW  80
0C34:  MOVWF  F94
....................     setup_adc(ADC_CLOCK_INTERNAL);
0C36:  MOVF   FC0,W
0C38:  ANDLW  C0
0C3A:  IORLW  07
0C3C:  MOVWF  FC0
0C3E:  BCF    FC0.7
0C40:  BSF    FC2.0
....................     setup_spi(SPI_SS_DISABLED);
0C42:  BCF    FC6.5
0C44:  BCF    F94.5
0C46:  BSF    F94.4
0C48:  BCF    F94.3
0C4A:  MOVLW  01
0C4C:  MOVWF  FC6
0C4E:  MOVLW  00
0C50:  MOVWF  FC7
....................     //setup_wdt(WDT_OFF);
....................     
....................     can_init();
0C52:  BRA    0928
....................     // Do not listen to any ID
....................     can_set_mode(CAN_OP_CONFIG);
0C54:  MOVLW  04
0C56:  MOVWF  55
0C58:  RCALL  08D8
0C5A:  CLRF   19
0C5C:  BTFSC  FF2.7
0C5E:  BSF    19.7
0C60:  BCF    FF2.7
....................     can_set_id((unsigned int *)RX0MASK, 0x7FF, 0); // Máscara 0 configura todos los bits como relevantes
0C62:  MOVLW  0F
0C64:  MOVWF  x97
0C66:  MOVLW  1B
0C68:  MOVWF  x96
0C6A:  CLRF   x9B
0C6C:  CLRF   x9A
0C6E:  MOVLW  07
0C70:  MOVWF  x99
0C72:  SETF   x98
0C74:  CLRF   x9C
0C76:  CALL   028E
0C7A:  BTFSC  19.7
0C7C:  BSF    FF2.7
0C7E:  CLRF   19
0C80:  BTFSC  FF2.7
0C82:  BSF    19.7
0C84:  BCF    FF2.7
....................       
....................     // Configuración de Filtros para el Buffer 0
....................     can_set_id((unsigned int *)RX0FILTER0, 0x03, 0); // Filtro 0 del buffer 0 para la ID 311
0C86:  MOVLW  0F
0C88:  MOVWF  x97
0C8A:  MOVLW  03
0C8C:  MOVWF  x96
0C8E:  CLRF   x9B
0C90:  CLRF   x9A
0C92:  CLRF   x99
0C94:  MOVWF  x98
0C96:  CLRF   x9C
0C98:  CALL   028E
0C9C:  BTFSC  19.7
0C9E:  BSF    FF2.7
....................       
.................... 
....................       
....................     // Configuración de Filtro para el Buffer 1
.................... 
....................     can_set_mode(CAN_OP_NORMAL);
0CA0:  CLRF   55
0CA2:  RCALL  08D8
....................     
....................     enable_interrupts(GLOBAL);
0CA4:  MOVLW  C0
0CA6:  IORWF  FF2,F
....................     enable_interrupts(int_canrx0); // Habilita la interrupción de recepción CAN
0CA8:  BSF    FA3.0
....................     enable_interrupts(INT_TIMER0); 
0CAA:  BSF    FF2.5
.................... 
....................     SET_TIMER0(TIME_INTERVAL_1MS); //
0CAC:  SETF   FD7
0CAE:  MOVLW  B3
0CB0:  MOVWF  FD6
....................    
....................     delay_ms(1300);//un poquillo de delay
0CB2:  MOVLW  0A
0CB4:  MOVWF  55
0CB6:  MOVLW  82
0CB8:  MOVWF  56
0CBA:  RCALL  0BA6
0CBC:  DECFSZ 55,F
0CBE:  BRA    0CB6
....................     
....................     while(TRUE)
....................     {
.................... 
....................          volatile INT32 id;
....................          volatile UNSIGNED int8 buffer[8]={0};
0CC0:  CLRF   48
0CC2:  CLRF   49
0CC4:  CLRF   4A
0CC6:  CLRF   4B
0CC8:  CLRF   4C
0CCA:  CLRF   4D
0CCC:  CLRF   4E
0CCE:  CLRF   4F
....................          int8 len=8;
....................          struct rx_stat rxstat;
0CD0:  MOVLW  08
0CD2:  MOVWF  50
....................          if (can_getd(id, buffer, len, rxstat)) {
0CD4:  CLRF   x89
0CD6:  MOVLW  48
0CD8:  MOVWF  x88
*
0F7A:  MOVF   01,F
0F7C:  BZ    0FBC
....................                buffer[0] = 1;
0F7E:  MOVLW  01
0F80:  MOVWF  48
....................                buffer[1] = 1;
0F82:  MOVWF  49
....................                buffer[2] = 1;
0F84:  MOVWF  4A
....................                buffer[3] = 1;
0F86:  MOVWF  4B
....................                buffer[4] = 1;
0F88:  MOVWF  4C
....................                buffer[5] = 1;
0F8A:  MOVWF  4D
0F8C:  CLRF   19
0F8E:  BTFSC  FF2.7
0F90:  BSF    19.7
0F92:  BCF    FF2.7
....................                can_putd(CAN_ID_PEDAL_BOARD,buffer,CAN_BUFFER_LENGTH,CAN_PRIORITY,false,false);
0F94:  MOVLB  0
0F96:  CLRF   x8B
0F98:  CLRF   x8A
0F9A:  CLRF   x89
0F9C:  MOVLW  01
0F9E:  MOVWF  x88
0FA0:  CLRF   x8D
0FA2:  MOVLW  48
0FA4:  MOVWF  x8C
0FA6:  MOVLW  08
0FA8:  MOVWF  x8E
0FAA:  MOVLW  11
0FAC:  MOVWF  x8F
0FAE:  CLRF   x90
0FB0:  CLRF   x91
0FB2:  CALL   03B6
0FB6:  BTFSC  19.7
0FB8:  BSF    FF2.7
0FBA:  MOVLB  E
....................          }
....................          //buffer[0] = 1;
....................          //buffer[1] = 1;
....................          //buffer[2] = 1;
....................          //buffer[3] = 1;
....................          //buffer[4] = 1;
....................          //buffer[5] = 1;
....................          //can_putd(CAN_ID_PEDAL_BOARD,buffer,CAN_BUFFER_LENGTH,CAN_PRIORITY,false,false);
....................          output_toggle(PIN_C4);
0FBC:  BCF    F94.4
0FBE:  BTG    F8B.4
....................          
....................          // Si se ha recibido el mensaje con ID 3 antes, enviamos el mensaje con ID 5
....................          
....................          delay_ms(10);
0FC0:  MOVLW  0A
0FC2:  MOVWF  56
0FC4:  MOVLB  0
0FC6:  RCALL  0BA6
0FC8:  BRA    0CC0
....................    }
.................... 
.................... }
0FCA:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
